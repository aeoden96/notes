<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0090)https://web.math.pmf.unizg.hr/nastava/opepp/Slides/Vjezbe/html-noslides/vjezbe-string.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 8.6.9">
<title>Stringovi</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Stringovi</h1>
<span id="author">Mladen Jurak</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2018-02</span>
</div>
<div id="content">
<div class="sect1">
<h2 id="_klasa_code_std_string_code">Klasa <code>std::string</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>String  u programskom jeziku C je niz znakova varijabilne duljine koji završava nul-znakom
(<code>\0)</code> koji označava kraj stringa.  Najčešće se alocira dinamički, a kretanje kroz njega se
vrši pomoću pokazivača na prvi element, uporabom pokazivačke aritmetike.</p></div>
<div class="paragraph"><p>U jeziku  C++ stringove iz jezika C (C-stringove) zamijenjuje klasa  <code>std::string</code>
koja brine o dinamičkoj alokaciji i dealokaciji niza znakova te nudi veliki broj metoda
za rad sa stringovima.</p></div>
<div class="paragraph"><p>Klasa  <code>string</code>  je ustvari specijalizacija predloška klase <code>basic_string&lt;T&gt;</code>. U imeniku <code>std</code> imamo
ove aliase:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">std</span><span class="p">{</span>
   <span class="k">typedef</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">string</span><span class="p">;</span>
   <span class="k">typedef</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">wchar_t</span><span class="o">&gt;</span> <span class="n">wstring</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Nizovne konstante, kao na primjer</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"OP(C++)"</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>su C-stringovi, odnosno nizovi znakova završeni  nul-znakom. Tip varijable <code>x</code> se deducira kao <code>const char *</code>.
Najčešće ih možemo koristiti tamo gdje se traži <code>std::string</code> zato što postoji implicitna konverzija
iz C-stringa u <code>std::string</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_definicija_i_inicijalizacija_stringova">Definicija i inicijalizacija stringova</h2>
<div class="sectionbody">
<div class="paragraph"><p>Da bismo koristili klasu <em>string</em> iz standardne biblioteke moramo uključiti
zaglavlje <em>string</em>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>String možemo inicijalizirati na različite načine. Na razini implementacije to znači da klasa
string ima više verzija konstruktora. Ovdje su dani neki od njih:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">s1</span><span class="p">;</span>                 <span class="c1">// Konstruktor bez argumenata konstrira prazan string</span>
<span class="n">string</span> <span class="nf">s2</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>             <span class="c1">// s2 je inicijaliziran kopijom stringa s1</span>
<span class="n">string</span> <span class="nf">s3</span><span class="p">(</span><span class="s">"ime i prezime"</span><span class="p">);</span><span class="c1">// s3 je inicijalizira konstantnim stringom</span>
<span class="n">string</span> <span class="nf">s4</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="sc">'x'</span><span class="p">);</span>         <span class="c1">// s4 je inicijaliziran sa 10 znakova 'x'</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Nul-znak (<code><em>\0</em></code>) nema posebno značenje u  <code>std::string</code> klasi i <code>string</code> ga može sadržavati kao i svaki drugi znak.
</p>
</li>
<li>
<p>
Ako nekoj funkciji koja uzima C-string treba predati <code>std::string</code> onda koristimo metodu <code>c_str()</code> koja vraća
  reprezentaciju stringa kao niza znakova završenog nul-znakom:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">str</span><span class="p">){</span>
<span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// ...</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">mystring</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="n">f</span><span class="p">(</span><span class="n">mystring</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</pre></div></div></div>
<div class="paragraph"><p>Povratna vrijednost <code>c_str()</code> funkcije je garantirano ispravna samo do poziva prve
operacije na stringu koja ga može promijeniti.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_citanje_i_pisanje_stringova">Čitanje i pisanje stringova</h2>
<div class="sectionbody">
<div class="paragraph"><p>Za čitanje stringova s tastature (standardni ulaz, <em>std::cin</em>) i njihovo ispisivanje na ekranu
(standardni izlaz, <em>std::cout</em>) koristimo  operatore   &lt;&lt; i  &gt;&gt; kao u ovom primjeru:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s1</span><span class="p">;</span><span class="c1">// Učitavanje stringa limitiranog bjelinama</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Ispis stringa</span>
</pre></div></div></div>
<div class="paragraph"><p>Prilikom učitavanja preskaču se početne bjeline, a učitavanje prestaje s prvom bjelinom.
Operacije čitanja i pisanja mogu se ulančavati kao u ovom primjeru:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s2</span> <span class="o">&gt;&gt;</span> <span class="n">s3</span><span class="p">;</span><span class="c1">// Čita prvo s2, a zatim s3.</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span> <span class="o">&lt;&lt;</span> <span class="n">s3</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// Ispisuje prvo s2, a zatim s3.</span>
</pre></div></div></div>
<div class="paragraph"><p>Želimo li učitavati s ulaza sve dok ne naiđemo na kraj ulaznih podataka (<em>end-of-file</em>)
trebamo koristiti sljedeću konstrukciju:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s1</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ukoliko dođe do greške pri upisu, ili smo došli do kraja ulazne datoteke,
<code>cin &gt;&gt; s1</code> će vratiti <em>false</em> i tada izlazimo iz <em>while</em> petlje. (Pod Linuxom/Unixom treba upisati
<em>Return</em> i <em>Ctr-D</em> kao znak za kraj datoteke.)</p></div>
<div class="paragraph"><p>Ulazni operator ne može pročitati string koji sadrži bjeline pa je stoga korisna funkcija <em>getline</em>
koja će pročitati čitavu liniju, sve do znaka za prijelaz u novi red koji se <strong>pročita i odbacuje</strong>.
Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span><span class="n">s1</span><span class="p">))</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Pri ispisu smo morali dodati <em>endl</em> jer znak za prijelaz u novi red nije učitan u <em>s1</em>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_operacije_na_stringovima">Operacije na stringovima</h2>
<div class="sectionbody">
<div class="paragraph"><p>U sljedećoj tabeli su navedene neke operacije koje možemo vršiti nad stringovima.</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="20%">
<col width="80%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s.empty()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća true ako je string prazan; inače false</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.size()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća broj znakova u <code>s</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s[n]</code></p></td>
<td align="left" valign="top"><p class="table">Vraća referencu na znak na poziciji <code>n</code>. Prvi znak je na poziciji 0. Ne provjerava je li indeks u granicama.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.at(i)</code></p></td>
<td align="left" valign="top"><p class="table">Isto što i  <code>s[n]</code> ali provjerava je li indeks u granicama i izbacuje izuzetak.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s1 + s2</code></p></td>
<td align="left" valign="top"><p class="table">Vraća string koji  je jednak konkatenaciji stringova <code>s1</code> i <code>s2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s1 = s2</code></p></td>
<td align="left" valign="top"><p class="table">Zamijenjuje string <code>s1</code> kopijom stringa <code>s2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s1 == s2</code></p></td>
<td align="left" valign="top"><p class="table">Ispituje jednakost stringova <code>s1</code> i <code>s2</code>; <em>true</em> ako su jednaki, <em>false</em> ako nisu.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>!=, &lt; , &lt;=, &gt;, &gt;=</code></p></td>
<td align="left" valign="top"><p class="table">Relacijski operatori provjeravaju leksikografski poredak.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Nadovezivanje jednog stringa na drugi (konkatenacija) vrši se pomoću operatora
zbrajanja. Ti su operatori (+, +=) redefinirani u klasi string kako bi mogli biti
primijenjeni na stringove.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"AAA"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">str2</span> <span class="o">=</span> <span class="s">"BBB"</span><span class="p">;</span>
<span class="n">string</span> <span class="n">str3</span> <span class="o">=</span> <span class="n">str1</span> <span class="o">+</span> <span class="n">str2</span><span class="p">;</span><span class="c1">// Konkatenacija dvaju stringova</span>
<span class="n">string</span> <span class="n">str4</span> <span class="o">=</span> <span class="n">str3</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span><span class="c1">// Konkatenacija stringa i konstantnog znakovnog niza</span>

<span class="n">str1</span> <span class="o">+=</span> <span class="n">str4</span><span class="p">;</span> <span class="c1">// Dodavanje stringa str4 na str1</span>

<span class="k">for</span><span class="p">(</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str4</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">str4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'B'</span><span class="p">)</span> <span class="n">str4</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'X'</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Indeks koji treba koristiti za kretanje kroz string je tipa <code>string::size_type</code>.</p></div>
<div class="paragraph"><p>String predstavljaja jedan sekvencijalni spremik, specijaliziran za držanje znakova. Kao i kod vektora,
znakovi se čuvaju na uzastopnim lokacijama u memoriji što dozvoljava efikasno indeksiranje niza. String je stoga vrlo
blizak spremniku <code>vector</code> i <strong>podržava operacije koje podržava</strong> <code>vector</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_indeksirane_operacije">Indeksirane operacije</h2>
<div class="sectionbody">
<div class="paragraph"><p>String podržava operacije <code>insert</code>, <code>erase</code> i <code>assign</code> koje rade s iteratorima ili
parovima iteratora, ali nudi i paralelne metode koje rade s indeksima umjesto iteratora. Te su operacije dane u sljedećoj tabeli
u kojoj su <code>pos</code> i <code>pos2</code> indeksi:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="40%">
<col width="60%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s.insert(pos, n, c)</code></p></td>
<td align="left" valign="top"><p class="table">Ubacuje <code>n</code> kopija znaka <code>c</code> ispred elementa indeksiranog s <code>pos</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.insert(pos, s2)</code></p></td>
<td align="left" valign="top"><p class="table">Ubacuje kopiju stringa <code>s2</code> ispred znaka s pozicijom <code>pos</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.insert(pos, s2, pos2, len)</code></p></td>
<td align="left" valign="top"><p class="table">Ubacuje <code>len</code> znakova iz stringa <code>s2</code>, počevši od pozicije <code>pos2</code>, ispred znaka s pozicijom <code>pos</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.insert(pos, len, cp)</code></p></td>
<td align="left" valign="top"><p class="table">Ubacuje <code>len</code> znakova iz polja na koje pokazuje <code>cp</code> ispred znaka s pozicijom <code>pos</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.insert(pos, cp)</code></p></td>
<td align="left" valign="top"><p class="table">Ubacuje kopiju znakovnog niza na koji pokazuje <code>cp</code> (koji mora biti završen nul-znakom) ispred znaka s pozicijom <code>pos</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.assign(s2)</code></p></td>
<td align="left" valign="top"><p class="table">Zamijeni <code>s</code> s kopijom od <code>s2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.assign(s2, pos2, len)</code></p></td>
<td align="left" valign="top"><p class="table">Zamijeni <code>s</code> s kopijom od <code>len</code> znakova iz  <code>s2</code> koji počinju na poziciji <code>pos2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.assign(cp, len)</code></p></td>
<td align="left" valign="top"><p class="table">Zamijeni <code>s</code> s kopijom od <code>len</code> znakova iz polja na koje pokazuje  <code>cp</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.assign(cp)</code></p></td>
<td align="left" valign="top"><p class="table">Zamijeni <code>s</code> sa znakovnim nizom (završenim nul-znakom) iz polja na koje pokazuje  <code>cp</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.erase(pos, len)</code></p></td>
<td align="left" valign="top"><p class="table">Obriši <code>len</code> znakova polazeći od pozicije <code>pos</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Sve operacije vraćaju referencu na <code>s</code>.</p></div>
<div class="paragraph"><p>Neki primjeri su dani ovdje:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="nf">s1</span><span class="p">(</span><span class="s">"Dobar dan."</span><span class="p">);</span>
<span class="n">string</span> <span class="n">s2</span><span class="p">;</span>
<span class="n">s2</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>            <span class="c1">// s2 = "dan"</span>
<span class="n">s2</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">);</span> <span class="c1">// s2 = "bar dan."</span>
<span class="n">s2</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="sc">'v'</span><span class="p">);</span>             <span class="c1">// s2 = "vvv"</span>

<span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s1</span><span class="p">);</span>              <span class="c1">// s2 = "Dobar dan.vvv"</span>
<span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>      <span class="c1">// s2 = "Dobar dan.dan.vvv"</span>
<span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="sc">'x'</span><span class="p">);</span>         <span class="c1">// s2 = "xxxDobar dan.dan.vvv"</span>
<span class="n">s2</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>                <span class="c1">// s2 = "xxxDobar.dan.vvv"</span>
</pre></div></div></div>
<div class="paragraph"><p><code>std::string::npos</code> služi kao oznaka za kraj stringa.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_substringovi">Substringovi</h2>
<div class="sectionbody">
<div class="paragraph"><p>Iz svakog stringa možemo izvući odgovarajući podstring pomoću <code>substr</code> operacije.
Operacija vraća kopiju novostvorenog stringa.</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s.substr(pos, n)</code></p></td>
<td align="left" valign="top"><p class="table">Vraća string koji sadrži <code>n</code> znakova iz stringa <code>s</code> počevši od pozicije <code>pos</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.substr(pos)</code></p></td>
<td align="left" valign="top"><p class="table">Vraća string koji sadrži znakove od pozicije <code>pos</code> do kraja od <code>s</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.substr()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća kopiju od <code>s</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_append_i_replace">append i replace</h3>
<div class="paragraph"><p>Postoji više preopterećenih verzija funkcije <code>append</code> ifunkcije <code>replace</code>.
Funkcija <code>append</code> dodaje znakove na kraj stringa; funkcija <code>replace</code> zamijenjuje raspon znakova
drugim znakovima. Pri tome zamjena jednog skupa znakova drugim znači da se prvi skup briše (<code>erase</code>)
i zatim se na to mjesto ubacuje novi skup znakova (<code>insert</code>).</p></div>
<div class="paragraph"><p>Funkcije <code>append</code> i <code>replace</code> razlikuju se po načinu na koji se zadaje raspon
znakova koje ubacujemo, a
 funkcije <code>replace</code> se razlikuju i po načinu zadavanja raspona elemenata koji se izbacuju (zamijenjuju)
iz stringa.  Metode su dane ovdje:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s.append(args)</code></p></td>
<td align="left" valign="top"><p class="table">Dodaj <code>args</code> na <code>s</code>. Vraća referencu na <code>s</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.replace(pos, len, args)</code></p></td>
<td align="left" valign="top"><p class="table">Izbaci <code>len</code> znakova iz <code>s</code> počevši od pozicije <code>pos</code> i zamijeni ih
znakovima iz <code>args</code>. Vraća referencu na <code>s</code>.
Ova verzija ne uzima <code>args</code> u obliku <code>b2, e2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.replace(b, e, args)</code></p></td>
<td align="left" valign="top"><p class="table">Izbaci znakove u rasponu određenom s iteratorima <code>b, e</code>  iz <code>s</code>  i zamijeni ih
znakovima iz <code>args</code>. Vraća referencu na <code>s</code>.
Ova verzija ne uzima <code>args</code> u obliku <code>s2, pos2, len2</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Argumenti <code>args</code>, kojim se zadaju rasponi, dani su u ovoj tabeli:</p></div>
<div class="tableblock">
<table rules="all" style="margin-left:auto; margin-right:auto;" width="80%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s2</code></p></td>
<td align="left" valign="top"><p class="table">String <code>s2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s2, pos2, len2</code></p></td>
<td align="left" valign="top"><p class="table">Najviše <code>len2</code> znakova iz <code>s2</code> polazeći od <code>pos2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>cp</code></p></td>
<td align="left" valign="top"><p class="table">Znakovni niz na koji pokazuje <code>cp</code>, završen nul-znakom.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>cp, len2</code></p></td>
<td align="left" valign="top"><p class="table">Najviše <code>len2</code> znakova iz znakovnog niza na koji pokazuje <code>cp</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>n, c</code></p></td>
<td align="left" valign="top"><p class="table"><code>n</code> kopija znaka    <code>c</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>b2, e2</code></p></td>
<td align="left" valign="top"><p class="table">Znakovi u rasponu određenom iteratorima <code>b2</code> i <code>e2</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Primjer:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">s3</span><span class="p">{</span><span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">};</span>  <span class="c1">// s3 = "abc"</span>
<span class="n">s3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"defg"</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>   <span class="c1">// s3 = "abcdef"</span>
<span class="n">s3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="sc">'g'</span><span class="p">);</span>       <span class="c1">// s3 = "abcdefgg"</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="sc">'h'</span><span class="p">,</span><span class="sc">'i'</span><span class="p">,</span><span class="sc">'j'</span><span class="p">};</span>
<span class="n">s3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>   <span class="c1">// s3 = "abcdefgghij"</span>

<span class="n">s3</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="s">"--"</span><span class="p">);</span>     <span class="c1">// s3 = "--gghij"</span>
<span class="k">auto</span> <span class="n">s4</span> <span class="o">=</span> <span class="n">s3</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>   <span class="c1">// s4 = "ij"</span>
<span class="n">s3</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">s4</span><span class="p">);</span>       <span class="c1">// s3 ="--ij"</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_find">find</h2>
<div class="sectionbody">
<div class="paragraph"><p>Imamo šest verzija funkcija za pretraživanje stringa. Svaka od tih funkcija vraća  <code>string::size_type</code>
tip koji predstavlja indeks pozicije na kojoj je nađena tražena vrijednost. U slučaju negativnog rezultata
pretrage vraća se <code>string::npos</code> vrijednost, koja garantirano nije dobra vrijednost indeksa.</p></div>
<div class="paragraph"><p>Svaka od funkcija pretraživanja ima više preopterećenih varijanti koje se razlikuju po načinu na koji je
zadano ono što se traži.</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s.find(args)</code></p></td>
<td align="left" valign="top"><p class="table">Nađi prvo pojavljivanje  <code>args</code> u  <code>s</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.rfind(args)</code></p></td>
<td align="left" valign="top"><p class="table">Nađi zadnje pojavljivanje  <code>args</code> u  <code>s</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.find_first_of(args)</code></p></td>
<td align="left" valign="top"><p class="table">Nađi prvo pojavljivanje bilo kojeg znaka iz <code>args</code> u  <code>s</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.find_last_of(args)</code></p></td>
<td align="left" valign="top"><p class="table">Nađi zadnje pojavljivanje bilo kojeg znaka iz <code>args</code> u  <code>s</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.find_first_not_of(args)</code></p></td>
<td align="left" valign="top"><p class="table">Nađi prvi znak u  <code>s</code> koji nije iz <code>args</code> .</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.find_last_not_of(args)</code></p></td>
<td align="left" valign="top"><p class="table">Nađi zadnji znak u  <code>s</code> koji nije iz <code>args</code> .</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Argument <code>args</code> koji se traži dan je ovoj tabeli:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="20%">
<col width="80%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>c, pos</code></p></td>
<td align="left" valign="top"><p class="table">Traži znak <code>c</code> polazeći od pozicije <code>pos</code> u <code>s</code>.  Defaultna vrijednost za <code>pos</code> je nula.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s2, pos</code></p></td>
<td align="left" valign="top"><p class="table">Traži string <code>s2</code> polazeći od pozicije <code>pos</code> u <code>s</code>.  Defaultna vrijednost za <code>pos</code> je nula.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>cp, pos</code></p></td>
<td align="left" valign="top"><p class="table">Traži znakovni niz završen nul-znakom na koji pokazuje <code>cp</code> polazeći od pozicije <code>pos</code> u <code>s</code>.  Defaultna vrijednost za <code>pos</code> je nula.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>cp, pos, n</code></p></td>
<td align="left" valign="top"><p class="table">Traži prvih <code>n</code> znakova u znakovnom nizu na koji pokazuje <code>cp</code>
polazeći od pozicije <code>pos</code> u <code>s</code>.  Defaultna vrijednost za <code>pos</code> je nula.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Primjer:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="nf">s5</span><span class="p">(</span><span class="s">"Molim da ne koristite preopterećenje operatora i funkcija u svom programu."</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s5</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"preopterećenje"</span><span class="p">);</span>  <span class="c1">// n = 22</span>
<span class="n">n</span> <span class="o">=</span><span class="n">s5</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"i"</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>                 <span class="c1">// n = 48</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">s5</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="s">"preopterećenje"</span><span class="p">);</span>      <span class="c1">// n = 22</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">s5</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">"kd"</span><span class="p">);</span>          <span class="c1">// n=6, nalazi "d"</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">s5</span><span class="p">.</span><span class="n">find_first_not_of</span><span class="p">(</span><span class="s">"Mmkdol"</span><span class="p">);</span>  <span class="c1">// n=3, nalazi "i"</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">s5</span><span class="p">.</span><span class="n">find_last_not_of</span><span class="p">(</span><span class="s">"Mmkdol"</span><span class="p">);</span>   <span class="c1">// n=74, nalazi "."</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_compare">compare</h2>
<div class="sectionbody">
<div class="paragraph"><p>Za uspoređivanje stringova možemo koristiti operatore <code>==, !=, &lt;, &gt;, &lt;=</code> i <code>&gt;=</code>.
Svi oni vrše leksikografsko uspoređivanje, znak-po-znak. To znači da se uspoređuju odgovarajući znakovi
u stringovima sve dok se ne naiđe na prvi par znakova koji su različiti. Usporedba je tada određena
odnosnom ta dva znaka, čiji je pak poredak fiksiran abecedom. Mala slova prethode velikim slovima, a velika slova prethode
brojevima. Ako je jedan string podstring drugog, onda je dulji string veći.</p></div>
<div class="paragraph"><p>Pored operatora uspoređivanja string daje šest preopterećenih verzija funkcije <code>compare</code>
koja vrši leksikografsko uspoređivanje. Rezultat tih funkcija je analogan rezultatu koji daje funkcija
<code>strcmp</code> iz standardne biblioteke jezika C. Dakle,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s1</span><span class="p">.</span><span class="n">compare</span> <span class="p">(</span><span class="n">args</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>daje sljedeći rezultat:</p></div>
<div class="ulist"><ul>
<li>
<p>
Pozitivnu vrijednost ako je <code>s1</code> veći od stringa kojeg reprezentira <code>args</code>;
</p>
</li>
<li>
<p>
Negativnu vrijednost ako je <code>s1</code> manji od stringa kojeg reprezentira <code>args</code>;
</p>
</li>
<li>
<p>
Nulu ako je <code>s1</code>  jednak stringu kojeg reprezentira <code>args</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Funkcije su dane ovdje:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>s.compare(s2)</code></p></td>
<td align="left" valign="top"><p class="table">Uspoređuje <code>s</code> i <code>s2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.compare(pos1, n1, s2)</code></p></td>
<td align="left" valign="top"><p class="table">Uspoređuje <code>n1</code> znakova iz <code>s</code>, počevši od pozicije <code>pos1</code>, sa  <code>s2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.compare(pos1, n1, s2, pos2, n2)</code></p></td>
<td align="left" valign="top"><p class="table">Uspoređuje <code>n1</code> znakova iz <code>s</code>, počevši od pozicije <code>pos1</code>, sa
<code>n2</code> znakova iz <code>s2</code> počevši od <code>pos2</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.compare(cp)</code></p></td>
<td align="left" valign="top"><p class="table">Uspoređuje <code>s</code> i znakovni niz završen nul-znakom na koji pokazuje <code>cp</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.compare(pos1, n1, cp)</code></p></td>
<td align="left" valign="top"><p class="table">Uspoređuje <code>n1</code> znakova iz <code>s</code>, počevši od pozicije <code>pos1</code>, sa znakovnim nizom završenim nul-znakom na koji pokazuje <code>cp</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>s.compare(pos1, n1, cp, n2)</code></p></td>
<td align="left" valign="top"><p class="table">Uspoređuje <code>n1</code> znakova iz <code>s</code>, počevši od pozicije <code>pos1</code>, sa <code>n2</code> znakova počevši od pozicije na koju pokazuje <code>cp</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Version 1.0<br>
Zadnja izmjena
 2019-05-14 19:36:49 CEST
</div>
</div>


</body></html>