<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0091)https://web.math.pmf.unizg.hr/nastava/opepp/old/Slides/Vjezbe/html-noslides/vjezbe-aux.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 9.0.0rc1">
<title>Pomoćna sredstva</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overridden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Pomoćna sredstva</h1>
<span id="author">Mladen Jurak</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2020-04</span>
</div>
<div id="content">
<div class="sect1">
<h2 id="_code_assert_code_makro"><code>assert</code> makro</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>assert</code> je preprocesorska naredba (makro) koja služi za ispitivanje da li je
neki uvjet zadovoljen ili nije. Koristi se kao funkcija koja uzima jedan argument
tipa <code>bool</code> ili <code>int</code> te ne čini ništa ako se argument izračunava na <code>true</code> ili
broj različit od nule, a zaustavlja izvršavanje programa ako se izračunava na <code>false</code>
ili  nulu.</p></div>
<div class="paragraph"><p>Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;  // Nužno za assert makro!</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ovdje se ispituje da li je <code>a.size()</code> jednako <code>4</code>. Ako jeste program se nastavlja,
a ako nije bit će zaustavljen s porukom o grešci. Na primjer, ako u <code>assert</code> uvjetu
zamijenimo <code>4</code> sa <code>5</code> dobit ćemo sljedeću poruku o grešci:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>main: /.../Assert/main.cpp:13: int main(): Assertion `a.size() == 5' failed.
Aborted</code></pre>
</div></div>
<div class="paragraph"><p>Vidimo da nam <code>assert</code> daje uvjet koji nije ispunjen
 i liniju koda u kojoj se nalazi <code>assert</code> koji je zaustavio
program.</p></div>
<div class="paragraph"><p>Assert makro je sredstvo za provjeru ispravnosti koda i koristi se u fazi razvoja koda.
Koristimo ga provjeru ispravnosti različitih invarijanti u kodu. Kada je kod završen
sve <code>assert</code> naredbe mogu se jednostavno eliminirati iz programa. To se postiže time što
preprocesor definira <code>assert</code> makro u ovisnosti o simbolu <code>NDEBUG</code>: ako simbol
 <code>NDEBUG</code> nije definiran tada  <code>cassert</code> makro radi na opisan način; ako je  <code>NDEBUG</code>  definiran
onda se  <code>assert</code> naredba pretvara u trivijalnu naredbu koju prevodilac eliminira iz koda.
Da bismo eliminirali <code>assert</code> naredbe <code>NDEBUG</code> treba definirati <strong>prije točke uključivanja</strong>
<code>&lt;cassert&gt;</code> zaglavlja. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#define NDEBUG 1</span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;  // Nužno za assert makro!</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>sada <code>assert</code> naredba ne zaustavlja program.</p></div>
<div class="paragraph"><p>Ubacivanje <code>#define NDEBUG</code> linije nije najpraktičniji način za eliminaciju <code>assert</code>
naredbi pogotovo ako program ima puno datoteka koje koriste <code>assert</code>.
Bolja opcija je da se simbol <code>NDEBUG</code> definira na komandnoj liniji pri kompilaciji pomoću -D opcije:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>g++ -Wall -O3 -DNDEBUG main.cpp</code></pre>
</div></div>
<div class="paragraph"><p>Opcija  -DNDEBUG učinit će simbol <code>NDEBUG</code> definiran.</p></div>
<div class="paragraph"><p>Ako koristimo CMake tada treba program kompilirati u <code>Release</code> načinu i Cmake će ubaciti
 -DNDEBUG opciju prevodiocu za nas. Na primjer, u <code>build</code> direktoriju naredbe</p></div>
<div class="listingblock">
<div class="content">
<pre><code>cmake -DCMAKE_BUILD_TYPE=Release ..
make VERBOSE=1</code></pre>
</div></div>
<div class="paragraph"><p>će kompilirati program u Release načinu. Opcija VERBOSE=1 nam omogućava da vidimo koje su
opcije poslane prevodiocu. Dobivamo:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> [50%] Building CXX object CMakeFiles/main.dir/main.cpp.o
/usr/bin/c++  -O3 -DNDEBUG -o CMakeFiles/main.dir/main.cpp.o -c /.../Assert/main.cpp</code></pre>
</div></div>
<div class="paragraph"><p><code>assert</code> je nužno koristiti u što većoj mjeri za provjeru ispravnosti funkcioniranja programa.
Pri tome treba testirati uvjete koji vode na logičke greške unutar programa, a ne greške pri
izvršavanju koje dolaze od pogrešnog unosa podataka, pogrešnog korištenja programa, iscrpljivanja
resursa i slično. Te greške treba tretirati korištenjem izuzetaka.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_pomocna_klasa_std_pair">Pomoćna klasa std::pair</h2>
<div class="sectionbody">
<div class="paragraph"><p>Par (<code>std::pair</code>) je pomoćni tip deklariran je u zaglavlju <code>&lt;utility&gt;</code>.</p></div>
<div class="paragraph"><p>Tip <code>std::pair</code> sadrži dva podatka (dvije varijable) općenito različitih tipova koji čine (uređeni) par.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;utility&gt; // Za pair</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">ime_i_broj</span><span class="p">(</span><span class="s">"XCmp"</span><span class="p">,</span> <span class="mi">12345000</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ime    = "</span> <span class="o">&lt;&lt;</span> <span class="n">ime_i_broj</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">", broj = "</span> <span class="o">&lt;&lt;</span> <span class="n">ime_i_broj</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Konstruktor uzima dva argumenta kojima inicijalizira par.
</p>
</li>
<li>
<p>
Konstruktor bez argumenata vrši incijalizaciju nulama, odnosno pozivom konstruktora bez argumenata na elementima para.
</p>
</li>
<li>
<p>
Elementi se dohvaćaju kao <code>first</code> i <code>second</code> (javne varijable u klasi <code>std::pair&lt;T1,T2&gt;</code>).
</p>
</li>
<li>
<p>
Parove je moguće kopirati, pridruživati i uspoređivati ako su kompatiblinih tipova.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Radi uniformnosti pristupa elementi se mogu dohvatiti istom sintaksom kao i kod <code>tuple</code> spremnika:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ime_i_broj</span><span class="p">);</span>  <span class="c1">// isto što i x = ime_i_broj.first</span>
<span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ime_i_broj</span><span class="p">);</span>  <span class="c1">// isto što i y = ime_i_broj.second</span>
</pre></div></div></div>
<div class="paragraph"><p>Funcija <code>std::make_pair</code> kreira par iz zadane dvije vrijednosti i pri tome deducira tipove
elemenata para iz inicijalizacijskih vrijednosti.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">par</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="s">"ggg"</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span>
  <span class="c1">// par je tipa std::pair&lt;const char*, double&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Tipovi podataka koje <code>std::pair</code> drži mogu biti i reference te konstantne reference. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span><span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">par3</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">};</span>
<span class="n">par3</span><span class="p">.</span><span class="n">first</span><span class="o">++</span><span class="p">;</span>
<span class="n">par3</span><span class="p">.</span><span class="n">second</span><span class="o">++</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Funcija <code>std::make_pair</code> će prepoznati tip podataka kao referencu (konstantnu referencu) ako podatak
zamotamo u <code>std::ref()</code> (odnosno <code>std::cref()</code>) koji su definirani u zaglavlju <code>&lt;functional&gt;</code>. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="p">...</span>
<span class="c1">// deducira std::pair&lt;int const &amp;, int const &amp;&gt;</span>
<span class="k">auto</span> <span class="n">par4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="n">par4</span><span class="p">.</span><span class="n">first</span><span class="o">--</span><span class="p">;</span> <span class="c1">// greška, referenca je konstantna</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_konstrukcija_po_dijelovima">Konstrukcija po dijelovima</h3>
<div class="paragraph"><p>Konačno, postoji i konstruktor koji elemente para ne kopira iz inicijalizacijskih vrijednosti
već ih konstruira pozivajući odgovarajućih konstruktora. Argumenti tog konstruktora para se interpretiraju
kao argumenti konstruktora prvog, odnosno drugog člana para. Argumenti ovog konstruktora imaju
drukčije značenja od argumenata ostalih konstruktora pa stoga on dobiva dodatni argument
<code>std::piecewise_construct</code> koji služi samo da ga razlikuje od ostalih konstruktora.</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<caption class="title">Tabela 1. Konstruktor</caption>
<colgroup><col width="50%">
<col width="50%">
</colgroup><tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>std::pair&lt;T1,T2&gt; p(std::piecewise_construct, t1,t2)</code></p></td>
<td align="left" valign="top"><p class="table">Konstrukcija para u kojem se prvi član para konstruira pozivom
njegovog konstruktora s argumentima u <code>t1</code>, a drugi par se konstruira pozivom njegovog konstruktora s argumentima u <code>t2</code>.
Varijable <code>t1</code> i <code>t2</code> su tipa <code>tuple</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>U varijabli <code>t1</code> se nalaze argumenti konstruktora za tip <code>T1</code>, a u varijabli <code>t2</code> se nalaze argumenti konstruktora za tip <code>T2</code>.
Tip <code>tuple</code> koji se ovdje koristi je generalizacija para i može čuvati proizvoljan broj vrijednosti različitih tipova.
Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">X</span><span class="p">{</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span> <span class="n">mi</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">mc</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">mf</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span>   <span class="n">mi</span><span class="p">;</span>
    <span class="kt">char</span>  <span class="n">mc</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">mf</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">char</span><span class="p">,</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="sc">'a'</span><span class="p">,</span><span class="mf">2.0f</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="mf">3.0f</span><span class="p">);</span> <span class="c1">// argumenti konstruktora za tip X</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">par5</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">piecewise_construct</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">par5</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">mc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 'a'</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pomocna_klasa_code_std_tuple_code">Pomoćna klasa <code>std::tuple</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Tip <code>std::tuple</code>  je generaliracija tipa <code>std::pair</code> i predstavlja uređenu n-torku. On može držati proizvoljan ali fiksan broj
vrijednosti različitih tipova koji se zadaju kao parametri predloška. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">;</span> <span class="c1">// inicijalizacijama "nulama"</span>
</pre></div></div></div>
<div class="paragraph"><p>Objekt <code>t1</code> čuva tri vrijednosti redom tipa <code>double</code>, <code>int</code> i <code>std::string</code>; konstruktor bez argumenata vrši <em>vrijednosnu inicijalizaciju</em>
(inicijalizacija nulama).</p></div>
<div class="paragraph"><p>U sljedećem primjeru <code>std::tuple</code> drži dvije vrijednosti inicijalizirane u konstruktoru:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;complex&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">complex_literals</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">t2</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">i</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Vrijednosti se mogu dohvatiti pomoću funkcije <code>std::get</code> koja uzima indeks pozicije komponente:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.0</span><span class="o">+</span><span class="mi">4</span><span class="n">i</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Funkcija <code>std::make_tuple</code> kreira <code>tuple</code> deducirajući tipove iz argumenata kojima se inicijaliziraju.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="sc">'v'</span><span class="p">);</span>  <span class="c1">// kreira std::tuple&lt;int, double, char&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Kao i kod tipa <code>std::pair</code> pojedini tipovi u <code>std::tuple</code> mogu biti reference. Funkcija
<code>std::make_tuple</code> će deducirati referencu na tip (konstantnu referencu na tip) ako argument
zamotamo u <code>std::ref</code> (u <code>std::cref</code>) iz zaglavlja <code>&lt;functional&gt;</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_code_std_optional_lt_gt_code"><code>std::optional&lt;&gt;</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Parametrizirana klasa <code>std::optional&lt;T&gt;</code> (zaglavlje <code>&lt;optional&gt;</code>)
 može sadržavati vrijednost tipa <code>T</code> ali i ne mora,
odnosno može biti prazna. Koristi se za signaliziranje greške kada tražena vrijednost nije dostupna.</p></div>
<div class="paragraph"><p>Metode članice:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>has_value()</code> provjerava da li  objekt sadrži vrijednost. Postoji i operator konverzije u <code>bool</code> s
istom ulogom;
</p>
</li>
<li>
<p>
<code>value()</code>  vraća  sadržanu vrijednosti ili izbacuje <code>std::bad_optional_access</code> izuzetak. Istu ulogu
ima operator dereferenciranja;
</p>
</li>
<li>
<p>
<code>value_or(n)</code> vraća vrijednost ili (ako je nema) <code>n</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Dodijeljeni konstruktor konstruira prazan objekt.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Funkcija vraća int ali može i ne uspjeti.</span>
<span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">read_int</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="c1">// resetiraj stream -- poredak je važan</span>
        <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">(),</span> <span class="sc">'\n'</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">{};</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">add</span><span class="p">(</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">n</span><span class="p">,</span> <span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="n">and</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pročitao "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Neuspješno čitanje.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">read_int</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pročitao "</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">value</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Neuspješno čitanje.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>


    <span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">z</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">);</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"n+m = "</span> <span class="o">&lt;&lt;</span> <span class="n">z</span><span class="p">.</span><span class="n">value</span><span class="p">()</span>  <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Greška. "</span> <span class="o">&lt;&lt;</span> <span class="n">z</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// value_or(n) vrati vrijednost ili n.</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_code_std_any_code"><code>std::any</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>U zaglavlju <code>&lt;any&gt;</code> jedefiirana klasa <code>any</code> koja može sadržavati vrijednost bilo kojeg tipa.
Pored toga  <code>any</code> objekt može biti prazan.</p></div>
<div class="paragraph"><p>Metode članice:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>has_value()</code> provjerava da li  <code>any</code> objekt sadrži vrijednost;
</p>
</li>
<li>
<p>
<code>type()</code>  vraća <code>typeid</code> sadržane vrijednosti.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Globalna funkcija  <code>any_cast&lt;T&gt;(x)</code> vraća kopiju u <code>x</code> sadržanog objekta kao objekt tipa <code>T</code>.
Ako sadržani objekt nije tipa <code>T</code> baca <code>std::bad_any_cast</code> izuzetak. Ako rebamo referencu
koristimo  <code>any_cast&lt;T&amp;&gt;(x)</code>.</p></div>
<div class="paragraph"><p>Primjer:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">any</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">){</span>
   <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ništa.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">)){</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Tip je int, vrijednost = "</span>
            <span class="o">&lt;&lt;</span> <span class="n">any_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">string</span><span class="p">))</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Tip je string, vrijednost = "</span>
            <span class="o">&lt;&lt;</span> <span class="n">any_cast</span><span class="o">&lt;</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="k">else</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Nepoznati tip.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

   <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_code_std_variant_lt_gt_code"><code>std::variant&lt;&gt;</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Unija u programskom jeziku C (i C++) je struktura koja u istoj memorijskoj lokaciji može držati
više varijabli različitih tipova. Služi optimizaciji memorije. Odgovornost je programera
da dohvati tip varijable koji je spremljen u uniju.</p></div>
<div class="paragraph"><p><code>std::variant&lt;&gt;</code> (zaglavlje <code>&lt;variant&gt;</code>)
je moderna verzija unije. Tipovi koje može pohraniti su zadani kao parametri
predloška i svi dijele istu memorijsku lokaciju. Objekt tipa <code>std::variant&lt;&gt;</code> uvijek sadrži samo jednu
vrijednost i ne može biti <em>prazan</em>.</p></div>
<div class="paragraph"><p>Metode i globalne funkcije:</p></div>
<div class="ulist"><ul>
<li>
<p>
metoda <code>index()</code> vraća indeks tipa kojeg variant sadrži. Na primjer, ako <code>variant&lt;A,B,C&gt;::index()</code> vrati nulu
onda sadrži tip <code>A</code>, ako vrati 1 onda sadrži tip <code>B</code> te ako vrati 2, onda sadrži tip <code>C</code>.
</p>
</li>
<li>
<p>
globalna metoda <code>get&lt;n&gt;(x)</code> dohvaća element s indeksom <code>n</code> varijanta <code>x</code> (ili izbacuje izuzetak).
</p>
</li>
<li>
<p>
globalna metoda <code>get_if&lt;T&gt;()</code> uzima adresu variant objekta i vraća pokazivač tipa <code>T</code> na njegov sadržaj.
Ukoliko sadržaj nije tipa <code>T</code> vraća <code>nullptr</code>.
</p>
</li>
<li>
<p>
globalna metoda  <code>holds_alternative&lt;T&gt;(x)</code> vraća <code>true</code> ako <code>x</code> sadrži objekt tipa <code>T</code> i <code>false</code> inače.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Primjer.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span> <span class="n">list</span><span class="o">&lt;</span> <span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">lV</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">};</span>
     <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">lV</span><span class="p">){</span>
         <span class="k">switch</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">index</span><span class="p">()){</span>
           <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" Tip = int   : val = "</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
           <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" Tip = double: val = "</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Isti primjer pomoću <code>get_if&lt;&gt;</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">list</span><span class="o">&lt;</span> <span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">lV</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">lV</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span><span class="o">=</span><span class="n">get_if</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" Tip = int   : val = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="k">auto</span> <span class="n">q</span><span class="o">=</span><span class="n">get_if</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" Tip = double: val = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">q</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Primjer sa <code>holds_alternative&lt;T&gt;()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">is_type</span><span class="p">(</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">){</span>
  <span class="k">return</span> <span class="n">holds_alternative</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ..</span>
<span class="c1">// ne može direktno holds_alternative jer on deducira i tip varianta</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Imamo "</span>
     <span class="o">&lt;&lt;</span> <span class="n">count_if</span><span class="p">(</span><span class="n">lV</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lV</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">is_type</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
     <span class="o">&lt;&lt;</span> <span class="s">" objekata tipa int.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Primjer pomoću globalne funkcije <code>std::visit()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Funkcijski objekt koji može proći kroz sve tipove u variantu</span>
<span class="k">struct</span> <span class="n">Visitor</span><span class="p">{</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
   <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Visitor int: val = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">double</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
   <span class="p">{</span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Visitor double: val = "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// ....</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">lV</span><span class="p">)</span>
     <span class="n">visit</span><span class="p">(</span><span class="n">Visitor</span><span class="p">{},</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// primijeni visitora na variant</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_generiranje_slucajnih_brojeva">Generiranje slučajnih brojeva</h2>
<div class="sectionbody">
<div class="paragraph"><p>Biblioteka slučajnih brojeva je dana u zaglavlju <code>&lt;random&gt;</code> i uključuje:</p></div>
<div class="ulist"><ul>
<li>
<p>
Generatore (pseudo) slučajnih brojeva s uniformnom distribucijom
("Random number engines");
</p>
</li>
<li>
<p>
Različite distribucije — uniformna, normalna, Poissonova itd. Svaka
distribucija uzima generator slučajnih brojeva i generira brojeve sa
zadanom statističkom distribucijom.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Detalji se mogu naći na
<a href="http://en.cppreference.com/w/cpp/numeric/random">en.cppreference.com/w/cpp/numeric/random</a>.</p></div>
<div class="paragraph"><p>I generatori slučajnih brojeva (SB) i sve distribucije djeluju kao
funkcijski objekti. Pozivom generatora SB (bez argumenata) generira se
sljedeći SB. Isto tako, pozivom distribucije (sa generatorom SB kao
argumentom) dobiva se novi SB po toj distribuciji. Na generatoru je
nužno pozvati metodu <code>seed()</code> s nekim promjenjivim brojem (na primjer
trenutnim vremenom) kako se ne bi pri svakom pozivanju programa
generirao isti slučajni niz.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_primjer">Primjer</h2>
<div class="sectionbody">
<div class="paragraph"><p>Primjer korištenja dodijeljenog generatora:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;random&gt; // Uključi biblioteku slučajnih brojeva</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;  // Za trenutno vrijeme time(0)</span><span class="cp"></span>
<span class="c1">// ...</span>

<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">r_engine</span><span class="p">;</span> <span class="c1">// Generator slučajnih brojeva</span>
<span class="n">r_engine</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// seed = trenutno vrijeme,osigurava da</span>
                                     <span class="c1">// ne generiramo uvijek isti niz brojeva</span>
</pre></div></div></div>
<div class="paragraph"><p>Iskoristimo normalnu distribuciju sa očekivanjem 0 i standardnom
devijacijom 2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Normalna distribucija sa očekivanjem 0 i standardnom devijacijom 2.</span>
<span class="n">std</span><span class="o">::</span><span class="n">normal_distribution</span><span class="o">&lt;&gt;</span> <span class="n">nd</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
<span class="c1">// Svaka distribucija funkcionira kao funkcija koja uzima generator SB</span>
<span class="c1">// kao argument i vraća sljedeću SB dane distribucije.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">rand</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nd</span><span class="p">(</span><span class="n">r_engine</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"N(0,2) distribucija.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">rand</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_zadaci">Zadaci</h2>
<div class="sectionbody">
<div class="paragraph"><p><strong>Zadatak 1</strong>. Generirati vektor od 20 cijelih brojeva po binomnoj
distribuciji (npr. t=26, p=0.4). Na generiranom vektoru napraviti ove
operacije i ispisati rezultat.</p></div>
<div class="ulist"><ul>
<li>
<p>
Sortirati ga pomoću algoritma
<a href="http://en.cppreference.com/w/cpp/algorithm/sort">sort</a>.
</p>
</li>
<li>
<p>
Sortirati prvih 5 elemenata niza pomoću
<a href="http://en.cppreference.com/w/cpp/algorithm/partial_sort">partial_sort</a>.
</p>
</li>
<li>
<p>
Particionirati niz ako da peti element bude na svom mjestu, ispred
njega manji elementi, a iza njega veći elementi. Koristiti
<a href="http://en.cppreference.com/w/cpp/algorithm/nth_element">nth_element</a>.
</p>
</li>
<li>
<p>
Particionirati elemente tako da svi elementi manji od 10 budu ispred
elemenata većih ili jednakih 10. Prvi dio izdvojiti u novi vektor i
ispisati ga. Koristiti algoritam
<a href="http://en.cppreference.com/w/cpp/algorithm/partition">partition</a> i lambda
izraz.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Zadatak 2</strong>. Učitajte iz datoteke stringovi.txt niz stringova u vektor
pomoću <code>copy</code> algoritma. Zatim instancirajte
<a href="http://en.cppreference.com/w/cpp/container/set">set</a> pokazivača na
stringove i ubacite u njega adrese učitanih stringova. Ukoliko bismo
koristili spremnik <code>set&lt;string *&gt;</code> uređaj bi se odnosio na adrese
stringova, a ne na same stringove. Stoga treba setu dati dodatni
template parametar koji predstavlja tip binarnog operatora uspoređivanja
koji će uspoređivati stringove umjesto pokazivača na stringove. Dakle,
treba koristiti <code>set&lt;string *, Cmp&gt;</code> gdje je <code>Cmp</code> klasa koja
implementira binarni operator uspoređivanja. Nakon toga ispišite sadržaj
set-a na izlazni stream koristeći algoritam
<a href="http://en.cppreference.com/w/cpp/algorithm/transform">transform</a> te
<a href="http://en.cppreference.com/w/cpp/iterator/ostream_iterator">ostream_iterator</a>
i lambda funkciju koja će dereferencirati pokazivač na string (to je
transformacija koja se radi na svakom elementu). Stringovi moraju biti
ispisani u leksikografskom poretku.</p></div>
<div class="paragraph"><p><strong>Zadatak 3</strong>. Za normalnu distribuciju <code>N(mean,sigma)</code> ispišite
histogram - izračunati relativne frekvencije nalaženja broja u sljedećim
intervalima : [-3,-2),[-2,-1),[-1,0),[0,1),[1,2),[2,3). Srednja
vrijednost <code>mean</code> i standardna devijacija <code>sigma</code> neka su argumenti
kondne linije. Povećajte broj generiranih SB, mijenjajte parametre
distribucije. Napravite ispis oblika:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[-3,-2) : xx
[-2,-1) : xxxxxxxxxxxxx
[-1,-0) : xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[0,1)   : xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[1,2)   : xxxxxxxxxxxx
[2,3)   : xx</code></pre>
</div></div>
<div class="paragraph"><p>gdje svaki x predstavlja 1 % relativne frekvencije za dani interval.</p></div>
<div class="paragraph"><p>Za račun relativnih frekvencija koristite algoritam
<a href="http://en.cppreference.com/w/cpp/algorithm/count">std::count_if</a> s
predikatom zadanim <em>lambda izrazom</em>.</p></div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Version 1.0<br>
Zadnja izmjena
 2020-04-02 17:35:50 CEST
</div>
</div>


</body></html>