<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0091)https://web.math.pmf.unizg.hr/nastava/opepp/Slides/Predavanja/html-noslides/slides-1-2.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 8.6.9">
<title>Novi (&gt;= 2011) elementi jezika i standardne biblioteke</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Novi (&gt;= 2011) elementi jezika i standardne biblioteke</h1>
<span id="author">Mladen Jurak</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2018-02</span>
</div>
<div id="content">
<div class="sect1">
<h2 id="_inicijalizacijska_lista">Inicijalizacijska lista</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ovdje uvodimo one elemente jezika koji su se pojavili 2011. godine i kasnije.</p></div>
<div class="paragraph"><p>Polja možemo inicijalizirati vrijednostima smještenim u vitičastim
zagradama (inicijalizacijska lista):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">ivec</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Polje <code>ivec</code> automatski dobiva dimenziju 3. Posve analogno možemo inicijalizirati i obične varijable.
Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">l</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>    <span class="c1">// Inicijalizacija listom</span>
</pre></div></div></div>
<div class="paragraph"><p>Time imamo tri načina kojim možemo inicijalizirati varijablu:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// copy forma</span>
<span class="kt">int</span> <span class="nf">j</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>    <span class="c1">// Direktna forma</span>
<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span> <span class="c1">// Inicijalizacija listom</span>
<span class="kt">int</span> <span class="n">l</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>    <span class="c1">// Inicijalizacija listom</span>
</pre></div></div></div>
<div class="paragraph"><p>Svi su ti oblici ekvivalentni osim što
inicijalizacija listom ne dozvoljava konverzije
prilikom inicijalizacije u kojima dolazi do gubitka preciznost,
dok druge vrste inicijalizacija dozvoljavaju.</p></div>
<div class="paragraph"><p>Spremnici iz STL dozvoljavaju inicijalizaciju listom kada to ima smisla.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>        <span class="c1">// 3 elementa</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>      <span class="c1">// 3 elementa inicijalizirana s 1</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>        <span class="c1">// Inicijalizacija jednim elementom</span>
                              <span class="c1">// jednakim 3</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>  <span class="c1">// 5 elemenata</span>
<span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">e</span><span class="p">{</span><span class="s">"aa"</span><span class="p">,</span><span class="s">"bbc"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">set</span><span class="p">{</span><span class="s">"dune"</span><span class="p">,</span><span class="s">"deal.ii"</span><span class="p">,</span><span class="s">"libmesh"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">map</span><span class="p">{</span>
 <span class="p">{</span><span class="s">"Newton"</span><span class="p">,</span> <span class="s">"Isac"</span><span class="p">},</span> <span class="p">{</span><span class="s">"Euler"</span><span class="p">,</span> <span class="s">"I."</span><span class="p">},</span> <span class="p">{</span><span class="s">"Gauss"</span><span class="p">,</span> <span class="s">"F."</span><span class="p">}</span>
                                       <span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Višedimenzionalna polja inicijaliziramo listom vrijednosti na prirodan način.
Kod dvodimenzionalnih polja unutar vitičastih zagrada svaki pojedini redak stavljamo u vitičaste zagrade:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">va</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>      <span class="c1">// inicijalizacija višedimenzionalnog polja</span>
                      <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="c1">// prvi redak</span>
                      <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">}</span>  <span class="c1">// drugi redak</span>
                     <span class="p">};</span>

<span class="kt">int</span> <span class="n">vb</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span> <span class="c1">// ovo daje posve istu inicijalizaciju</span>

<span class="kt">int</span> <span class="n">vc</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">},{</span><span class="mi">2</span><span class="p">},{</span><span class="mi">3</span><span class="p">}};</span> <span class="c1">// drugi elementi su inicijalizirani</span>
                              <span class="c1">// prevodiocem; u svakom je retku prvi</span>
                              <span class="c1">// element inicijaliziran</span>

<span class="kt">int</span> <span class="n">vd</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// drugi elementi su inicijalizirani</span>
                            <span class="c1">// prevodiocem; elementi prvog retka</span>
                           <span class="c1">// su inicijalizirani</span>
</pre></div></div></div>
<div class="paragraph"><p>Inicijalizacijska lista se može koristiti i s dinamički alociranim poljima. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="o">*</span> <span class="n">pvec</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">5</span><span class="p">]{</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.3</span><span class="p">,</span><span class="mf">4.4</span><span class="p">,</span><span class="mf">5.5</span><span class="p">};</span>
 <span class="c1">// ..</span>
<span class="k">delete</span> <span class="p">[]</span> <span class="n">pvec</span><span class="p">;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_std_initializer_list_lt_t_gt">std::initializer_list&lt;T&gt;</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ako želimo da naša funkcija može uzeti kao parametar inicijalizacijsku listu
trebamo iskoristiti klasu <code>std::initializer_list&lt;T&gt;</code> koja je definirana u zaglavlju
<code>&lt;initializer_list&gt;</code>.
Klasa <code>std::initializer_list&lt;T&gt;</code> predstavlja listu argumenata, te nudi
<code>begin()</code> i <code>end()</code> metode za iteriranje kroz listu.
Klasa je vrlo slična klasi <code>std::vector</code> s ime da sadrži jedino <strong>konstantne vrijednosti</strong>
(tipa T). Na primjer, ako imamo</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="c1">// funkcija koja prima proizvoljno parametara tipa int</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// using u C++11 zamjenjuje typedef</span>
  <span class="k">using</span> <span class="n">Iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">il</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">il</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Funkciju <code>f()</code> zovemo na sljedeći način:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">});</span>
<span class="n">f</span><span class="p">({</span><span class="mi">34</span><span class="p">,</span><span class="mi">56</span><span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Ako tip koji funkcija vraća dozvoljava inicijalizaciju inicijalizacijskom listom, onda u
<code>return</code> naredbi možemo koristiti inicijalizacijsku listu.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">};</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_automatska_dedukcija_tipa_auto">Automatska dedukcija tipa: auto</h2>
<div class="sectionbody">
<div class="paragraph"><p>Kada želimo izračunatu vrijednost nekog izraza spremiti u varijablu trebamo odrediti tip
te varijable. Taj posao možemo prepustiti prevodiocu jer on ionako zna tip izraza; dovoljno je
varijablu deklarirati s <code>auto</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// prevodilac će učiniti z tipa double</span>
</pre></div></div></div>
<div class="paragraph"><p>Taj je mehanizam najkorisniji s predlošcima, gdje stvarni tip ne znamo.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">;</span>
        <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Postoji potpuna analogija između dedukcije tipa pri pozivu predloška funkcije i <code>auto</code> dedukcije tipa.
Auto dedukcija se može javiti u različitim oblicima ovisno o <em>dekoracijama</em> koje prate <code>auto</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>         <span class="c1">// slučaj 1</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>   <span class="c1">// slučaj 1</span>
<span class="k">auto</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>       <span class="c1">// slučaj 2</span>
<span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span> <span class="c1">// slučaj 2</span>
<span class="k">auto</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">expr</span><span class="p">;</span>      <span class="c1">// slučaj 3</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_slucaj_1">Slučaj 1</h3>
<div class="ulist"><ul>
<li>
<p>
Kada varijablu inicijaliziramo  drugom varijablom koja je <strong>referenca</strong> na neki tip,
<code>auto</code> u konstrukciji tipa <strong>ignorira referencu</strong>. Ako je referenca bila konstantna,
<code>auto</code> <strong>ignorira i const</strong>.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">k1</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>  <span class="c1">// daje:  int k1 = k;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>const</code> se ne ignorira kada su objekti konstantni:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">pk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">;</span> <span class="c1">// const int * pk = &amp;k;</span>
<span class="k">auto</span> <span class="n">pi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span> <span class="c1">// int * pi = &amp;i;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_slucaj_2">Slučaj 2</h3>
<div class="ulist"><ul>
<li>
<p>
Želimo li dobiti referencu trebamo ju eksplicitno zatražiti. Tada <code>const</code> <strong>neće biti ignoriran</strong>.
Jednako tako možemo dodati <code>const</code> u <code>auto</code> deklaraciju.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="o">&amp;</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>     <span class="c1">// const int &amp; k2 = k;</span>
<span class="k">const</span> <span class="k">auto</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// const int ii = i;</span>
</pre></div></div></div>
<div class="paragraph"><p>Konzistentnih <code>auto</code> deklaracija možemo imati više u jednoj liniji, jednako kao i standardnih.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_slucaj_3">Slučaj 3</h3>
<div class="ulist"><ul>
<li>
<p>
U ovom slučaju ponovo imamo <strong>univerzalnu referencu</strong>. Vrijedi isto pravilo kao i kod dedukcije parametra
predloška: ako inicijalizacijski  izraz ima lijevu vrijednost, tada se tip deducira kao lijeva referenca;
ako inicijalizacijski  izraz ima desnu vrijednost, tada se tip deducira kao desna referenca.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span>  <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">//  int &amp; k = i;</span>
<span class="k">auto</span>  <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// int &amp;&amp; k = 3;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_auto_i_univerzalna_inicijalizacija">auto i univerzalna inicijalizacija</h3>
<div class="paragraph"><p>Ako varijablu inicijaliziramo izrazom u vitičastim zagradama i koristimo <code>auto</code> za dedukciju tipa,
<code>auto</code> će deducirati  <code>std::initializer_list</code>. Stoga <code>auto</code>
ne treba koristiti u takvoj situaciji.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">v1</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// o.k v1 je tipa int</span>
<span class="k">auto</span> <span class="n">v2</span><span class="o">=</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="c1">// greška! v2 je tipa std::initializer_list&lt;int&gt;</span>
<span class="k">auto</span> <span class="n">v3</span><span class="o">=</span><span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">};</span> <span class="c1">// v3 je tipa std::initializer_list&lt;int&gt;</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_automatska_dedukcija_tipa_decltype">Automatska dedukcija tipa: decltype</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>auto</code> omogućava određivanje tipa varijable na osnovu tipa izraza <strong>samo pri
inicijalizaciji varijable</strong>. U drugim slučajevima koristimo <code>decltype</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">())</span> <span class="n">sum</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// sum ima tip koji vraća f()</span>
</pre></div></div></div>
<div class="paragraph"><p><code>decltype</code> određuje tip varijable <code>sum</code> na osnovu povratnog tipa funkcije <code>f()</code>. Pri tome se sama funkcija
<strong>ne izračunava</strong>.</p></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Kada se <code>decltype</code> primijenjuje <strong>na varijablu</strong> on vraća tip varijable <strong>bez ignoriranja</strong>
konstantnosti i reference.</td>
</tr></tbody></table>
</div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">double</span> <span class="n">xx</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">xx</span><span class="p">;</span>

<span class="k">decltype</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="n">uu</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// const double uu = 1.0;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">yy</span><span class="p">)</span> <span class="n">vv</span><span class="p">;</span>    <span class="c1">//  const double &amp; vv; greška</span>
                    <span class="c1">//  neinicijalizirana referenca</span>
<span class="n">vv</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>           <span class="c1">// greška - vv je const</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Kada se <code>decltype</code> primijenjuje <strong>na izraz</strong> dobit će se lijeva referenca ako
izraz ima lijevu vrijednost. Ako izraz ima desnu vrijednost dobiva se tip bez reference.</td>
</tr></tbody></table>
</div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ra</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">ra</span><span class="p">)</span> <span class="n">newa</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="n">nnewa</span><span class="p">;</span>  <span class="c1">// double &amp; nnewa; greška</span>
                      <span class="c1">// neinicijalizirana referenca</span>
<span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">pa</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="n">ab</span><span class="p">;</span>  <span class="c1">// double ab;</span>
<span class="k">decltype</span><span class="p">(</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">)</span> <span class="n">ac</span><span class="p">;</span>    <span class="c1">// greška - double &amp; ac;</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Dereferencirani pokazivač može stajati na lijevoj strani i stoga   decltype(*pa)
vraća referencu.
</p>
</li>
<li>
<p>
Ako dereferenciranom pokazivaču dodamo nulu dobivamo izraz koji ne može stajati na lijevoj strani
operatora pridruživanja i stoga
<code>decltype(*pa + 0)</code> nije referenca.
</p>
</li>
<li>
<p>
Kada varijablu stavimo u oble zagrade prevodilac to interpretira kao izraz i stoga
<code>decltype( (a) )</code> vraća referencu (varijabla uvijek može stajati na lijevoj strani
operatora pridruživanja).
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="_kako_prikazati_deducirani_tip">Kako prikazati deducirani tip?</h3>
<div class="paragraph"><p>Postoji više načina. Jedan je iskoristiti prevodilac:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">TD</span><span class="p">;</span>      <span class="c1">// Klasa nije definirana što će inicirati</span>
               <span class="c1">// grešku pri prevođenju</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">TD</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">td</span><span class="p">;</span> <span class="c1">// prevodilac će pokazati tip decltype(i)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ispis greške prevocioca:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="o">-</span><span class="k">decltype</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span> <span class="n">In</span> <span class="n">function</span> <span class="err">‘</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span><span class="err">’</span><span class="o">:</span>
<span class="k">auto</span><span class="o">-</span><span class="k">decltype</span><span class="p">.</span><span class="nl">cpp</span><span class="p">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">19</span><span class="o">:</span> <span class="nl">error</span><span class="p">:</span> <span class="n">aggregate</span> <span class="err">‘</span><span class="n">TD</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;&gt;</span> <span class="n">td</span><span class="err">’</span>
<span class="n">has</span> <span class="n">incomplete</span> <span class="n">type</span> <span class="n">and</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">defined</span>
   <span class="n">TD</span> <span class="n">td</span><span class="p">;</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nova_sintaksa_funkcije">Nova sintaksa funkcije</h2>
<div class="sectionbody">
<div class="paragraph"><p>C++2011 dozvoljava sintaksu funkcije u kojoj povratni tip dolazi nakon funkcijskih argumenata
(<em>trailing return type</em>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="c1">// ...</span>
   <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Takva sintaksa je najkorisnija kod predložaka funkcije jer se povratni tip može deducirati pomoću
<code>decltype</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">g</span><span class="p">(</span><span class="n">T1</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">t2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="n">t2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ovakva sintaksa upotrebljava <code>decltype</code> <em>pravila za dedukciju tipa</em>. Na primjer, uz definiciju</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">g</span><span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="n">I</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>sljedeći kod je ispravan:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">};</span>
<span class="n">g</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>jer je deducirani  povratni tip <code>double &amp;</code>.</p></div>
<div class="paragraph"><p>Prema standardu C++14 prevodilac može u potpunosti deducirati povratni tip (ako u svim <code>return</code> naredbama
nađe izraze istog tipa). Stoga možemo pisati:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">g</span><span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="n">I</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ali, sada se primijenjuju <code>auto</code> <em>pravila za dedukciju tipa</em>.  To znači da u primjeru</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">};</span>
<span class="n">g</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> <span class="c1">// greška</span>
</pre></div></div></div>
<div class="paragraph"><p>deducirani tip postaje <code>double</code> jer <code>auto</code> zanemaruje referencu. C++14 nudi sintaksu</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="p">,</span> <span class="k">typename</span> <span class="n">I</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">g</span><span class="p">(</span><span class="n">C</span> <span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span> <span class="n">I</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>kojom ponovo dobivamo <code>decltype</code> pravila za dedukciju povratnog tipa.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_range_for_petlja">range-for petlja</h2>
<div class="sectionbody">
<div class="paragraph"><p>Novi standard nudi pojednostavljenu for-naredbu sljedećeg oblika (tzv. <strong>range-for</strong> petlja):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="nl">deklaracija</span> <span class="p">:</span> <span class="n">izraz</span><span class="p">)</span>
    <span class="n">naredba</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ovdje <code>izraz</code> predstavlja niz elemenata — polje, višedimenzionalno polje, niz u vitičastim zagradama,
<code>string</code>, <code>vector</code>
ili bilo koji STL spremnik koji ima <code>begin()</code> i <code>end()</code> metode.</p></div>
<div class="paragraph"><p><code>deklaracija</code> mora biti takva deklaracija varijable da se element niza može konvertirati u
tu varijablu. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'a'</span><span class="p">,</span><span class="sc">'b'</span><span class="p">,</span><span class="sc">'c'</span><span class="p">,</span><span class="sc">'d'</span><span class="p">,</span><span class="sc">'e'</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">name</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>U svakom prolazu petlje, <code>x</code> dobiva novu vrijednost iz <code>name</code>. Petlja je ekvivalentna sa</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Kod deklaracije varijable u range-for petlji prirodno je koristiti <code>auto</code> i pustiti prevodiocu da deducira tip elementa
u spremniku:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">name</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ukoliko mijenjamo elemente spremnika treba varijablu deklarirati kao <strong>referencu</strong>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">name</span><span class="p">)</span>  <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Svi STL spremnici koji imaju  <code>begin</code> i <code>end</code> metodu mogu se koristiti u range-for
petlji, kao i eksplitno zadani nizovi:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.3</span><span class="p">};</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="p">{</span><span class="s">"aaa"</span><span class="p">,</span><span class="s">"bbb"</span><span class="p">,</span><span class="s">"ccc"</span><span class="p">})</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Kod višedimenzionalnih polja treba redak definirati kao referencu kako bi izbjegli
automatsku konverziju niza u pokazivač na prvi element niza:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">table</span><span class="p">[][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">}</span> <span class="p">};</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">row</span> <span class="p">:</span> <span class="n">table</span><span class="p">){</span>
   <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">col</span> <span class="p">:</span> <span class="n">row</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">col</span> <span class="o">&lt;&lt;</span> <span class="s">","</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Dinamički alocirano polje ne može se koristiti u range-for petlji.
</p>
</li>
<li>
<p>
Range-for petlja primijenjena na STL spremnike sprema end-iterator na početku
petlje pa se ne može koristiti za dodavanje/izbacivanje elemenata u/iz spremnik(a).
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_lambda_izrazi">Lambda izrazi</h2>
<div class="sectionbody">
<div class="paragraph"><p>Lambda izrazi (<em>lambda expressions</em>) su posebni funkcijski objekti koji se mogu opisati
kao bezimene inline funkcije. Sintaksa je slijedeća.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">lista</span> <span class="n">varijabli</span> <span class="n">iz</span> <span class="n">okru</span><span class="err">ž</span><span class="n">enja</span><span class="p">](</span><span class="n">lista</span> <span class="n">parametara</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">povratni</span> <span class="n">tip</span>
<span class="p">{</span> <span class="n">tijelo</span> <span class="n">funkcije</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Primjer.</strong> Sljedeća <em>lambda</em> izračunava treću potenciju broja:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">p3</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">;</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">p3</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Povratni tip (koji se piše novom sintaksom) ne moramo specificirati i tada se deducira. C++11 pravila kažu:</p></div>
<div class="ulist"><ul>
<li>
<p>
Ako lambda u tijelu ima samo jednu <code>return</code> naredbu, onda se povratni tip deducira iz <code>return</code> izraza.
</p>
</li>
<li>
<p>
Ako je tijelo lambda složenije od jedne <code>return</code> naredbe, onda je povratni tip <code>void</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Prema standardu C++14 povratna vrijednost se uvijek deducira prema <code>auto</code> pravilima dedukcije.
Na primjer:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">;</span> <span class="p">};</span> <span class="c1">// povratni tip se deducira kao double</span>
<span class="kt">double</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r3</span><span class="p">(</span><span class="mf">12.0</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Lambde najčešće koristimo kao argumente algoritama:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
                           <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
           <span class="p">);</span>


<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
               <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
                 <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
               <span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Napomena</strong>.  Ako lambda ne uzima argumente možemo ispustiti i oble zagrade. Jedino uglate zagrade moraju uvijek biti
prisutne.</p></div>
<div class="sect2">
<h3 id="_hvatanje_varijabli_iz_okruzenja_em_capture_em">Hvatanje varijabli iz okruženja (<em>capture</em>)</h3>
<div class="paragraph"><p>Lambda može dohvatiti varijable iz svog <em>lokalnog okruženja</em> navodeći ih u uglatim zagradama.
 Varijable se pišu odvojene zarezom.
Prijenos varijabli je po vrijednosti, odnosno po referenci ako se <code>&amp;</code> stavi ispred imena varijable.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">container</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">container</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="n">out</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Lambda vrši "hvatanje" varijabli tamo gdje je deklarirana, a ne tamo gdje je pozvana, što znači da
varijabla koju hvatamo mora biti definirana prije lambde. Sljedeći su oblici "hvatanja":</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>[]</code> prazne uglate zagrade znače da lambda ne hvata varijable iz svog okruženja.
</p>
</li>
<li>
<p>
<code>[x,y,&amp;z]</code> hvata tri varijable, <code>x</code> i <code>y</code> po vrijednosti i <code>z</code> po referenci.
</p>
</li>
<li>
<p>
<code>[&amp;]</code> hvata sve varijable iz svog okruženja po referenci.
</p>
</li>
<li>
<p>
<code>[=]</code> hvata sve varijable iz svog okruženja po vrijednosti.
</p>
</li>
<li>
<p>
<code>[&amp;,x,y]</code> hvata  sve varijable iz svog okruženja po referenci osim <code>x</code> i <code>y</code> koje hvata po vrijednosti.
</p>
</li>
<li>
<p>
<code>[=,x,y]</code> hvata  sve varijable iz svog okruženja po vrijednosti  osim <code>x</code> i <code>y</code> koje hvata po referenci.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Kada varijablu iz okruženja uhvatimo <strong>po vrijednosti</strong> ona se kopira unutar lambda-izraza
i njene daljnje promjene ne utječu na lambda izraz. Štoviše, kopija varijable unutar lambda izraza
je konstantna i ne možemo ju mijenjati.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">pi</span><span class="p">]()</span> <span class="p">{</span> <span class="n">pi</span> <span class="o">+=</span> <span class="mf">0.001</span><span class="p">;</span> <span class="k">return</span> <span class="n">pi</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="p">};</span>  <span class="c1">// greška</span>
</pre></div></div></div>
<div class="paragraph"><p>Ukoliko imamo potrebu promijeniti varijablu uhvaćenu po vrijednosti trebamo lambdu
deklarirati <code>mutable</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">pi</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="n">pi</span> <span class="o">+=</span> <span class="mf">0.001</span><span class="p">;</span> <span class="k">return</span> <span class="n">pi</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="p">};</span>   <span class="c1">// o.k.</span>
</pre></div></div></div>
<div class="paragraph"><p>Ako varijablu hvatamo <strong>po referenci</strong>, onda dobivamo referencu na varijablu i naša je
odgovornost da uhvaćena varijabla ima životni vijek koji nije kraći od vijeka lambde.
Varijabla uhvaćena po referenci nije konstantna i svaka njena promjena
reflektira se na lambdu.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">pi</span><span class="p">]()</span> <span class="p">{</span> <span class="n">pi</span> <span class="o">+=</span> <span class="mf">0.001</span><span class="p">;</span> <span class="k">return</span> <span class="n">pi</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span> <span class="p">};</span>

<span class="n">pi</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// ispisuje 36.012</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_em_init_capture_em"><em>Init capture</em></h3>
<div class="paragraph"><p>U standardu C++14 hvatanje varijabli iz okruženja je generalizirano i sada se može unutar
uglatih zagrada koristiti sintaksa <code>var = expr</code> (ili <code>&amp;var = expr</code>).
Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">pi</span> <span class="o">=</span> <span class="n">pi</span><span class="p">](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">(</span><span class="mf">1.11</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>U sintaksi  <code>var = expr</code>, <code>var</code> je varijabla unutar dosega lambde, dok je
<code>expr</code> izraz unutar okružujućeg dosega. To je razlog zbog kojega u prethodnom primjeru
možemo imati isto ime. Ova sintaksa daje puno više mogućnosti, na primjer:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="n">pi</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pi</span><span class="p">)](</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>gdje premještamo varijablu <code>pi</code> u lambdu.</p></div>
</div>
<div class="sect2">
<h3 id="_genericki_lambda_izrazi">Generički lambda izrazi</h3>
<div class="paragraph"><p>U dosadašnjim primjerima su argumenti lambda izraza morali biti
eksplicitno navedeni. Standard C++14 uvodi mogućnost da argumente deklariramo
s <code>auto</code>.  U tom slučaju se vrši standardna <code>auto</code> dedukcija parametara.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
              <span class="p">[](</span><span class="k">auto</span> <span class="n">x</span><span class="p">,</span> <span class="k">auto</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
         <span class="p">);</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_enumeracije">Enumeracije</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_enumeracija_vanjskog_dosega_code_enum_code">Enumeracija vanjskog dosega: <code>enum</code></h3>
<div class="paragraph"><p>Kada niz simboličkih imena želimo koristiti umjesto cjelobrojnih konstanti, onda
koristimo enumeraciju.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">Boja</span> <span class="p">{</span>
        <span class="n">plava</span><span class="p">,</span> <span class="n">crvena</span><span class="p">,</span> <span class="n">bijela</span><span class="p">,</span> <span class="n">crna</span><span class="p">,</span> <span class="n">siva</span>
    <span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Svaka enumeracija uvodi <em>novi tip</em> u program.
Enumeratori (<code>plava</code>, <code>crvena</code>, …) su <em>cjelobrojne konstante</em>;
prva dobiva vrijednost 0, druga 1, treća 2 itd.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="n">Boja</span>     <span class="c1">// Uvodi novi tip (Boja) u program.</span>
    <span class="p">{</span>
        <span class="n">plava</span><span class="p">,</span> <span class="n">crvena</span><span class="p">,</span> <span class="n">bijela</span><span class="p">,</span> <span class="n">crna</span><span class="p">,</span> <span class="n">siva</span>
    <span class="p">};</span>

    <span class="n">Boja</span>  <span class="n">fasada</span> <span class="o">=</span> <span class="n">plava</span><span class="p">;</span> <span class="c1">// fasada je varijabla tipa Boja</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fasada = "</span> <span class="o">&lt;&lt;</span> <span class="n">fasada</span> <span class="o">&lt;&lt;</span> <span class="s">", crvena =  "</span> <span class="o">&lt;&lt;</span> <span class="n">crvena</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">crvena</span> <span class="o">=</span> <span class="n">plava</span><span class="p">;</span>  <span class="c1">// Greška: plava, crvena,... su konstantne vrijednosti</span>
    <span class="kt">int</span> <span class="n">crvena</span><span class="p">;</span>      <span class="c1">// Greška: Ne možemo redefinirati ime crvena</span>
    <span class="n">fasada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// Greška: int se ne može konvertirati u tip Boja</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Imena navedna u enumeraciji eksportirana su u okružujući doseg.</td>
</tr></tbody></table>
</div>
<div class="paragraph"><p>Ako nam ne odgovaraju vrijednosti koje prevodilac pridružuje enumeratorima  možemo
im eksplicitno dati vrijednosti koje moraju biti konstantni cjelobrojni izrazi.
Svaki enumerator bez eksplicitne vrijednosti dobiva vrijednost za jedan veću od prethodne. Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">Boja</span> <span class="p">{</span>
        <span class="n">plava</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">crvena</span><span class="p">,</span> <span class="n">bijela</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">crna</span><span class="p">,</span> <span class="n">siva</span>
    <span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>daje vrijednosti</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">plava</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">crvena</span> <span class="o">=</span>  <span class="mi">13</span><span class="p">,</span> <span class="n">bijela</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">crna</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">siva</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Tip <code>enum</code> implicitno se konverira u (implementacijski zavisan) cjelobrojni tip.
</p>
</li>
<li>
<p>
Obratna konverzija cjelobronog tipa u enum-tip nije implicitna (treba koristiti <code>static_cast</code>).
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_enumeracija_unutarnjeg_dosega_code_enum_class_code">Enumeracija unutarnjeg dosega: <code>enum class</code></h3>
<div class="paragraph"><p>Standard C++11 uvodi novi tip enumeracije koji se definira sa <code>enum class</code>.
Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">Boje</span> <span class="p">{</span> <span class="n">plava</span><span class="p">,</span> <span class="n">crvena</span><span class="p">,</span> <span class="n">zelena</span> <span class="p">};</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<code>enum class</code> slijedi uobičajena pravila dosega. Izvan enumeracije enumeratori
se mogu dohvatiti samo kvalificirani imenom enumeracije (<code>Boje::plava</code>, …)
</p>
</li>
<li>
<p>
<code>enum class</code> ne dozvoljava implicitnu konverziju u cjelobrojni tip niti obratnu konverziju.
U oba slučaja moramo koristiti <code>static_cast&lt;&gt;</code>.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Boje</span> <span class="n">x</span> <span class="o">=</span> <span class="n">Boje</span><span class="o">::</span><span class="n">plava</span><span class="p">;</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">Boje</span><span class="o">::</span><span class="nl">plava</span> <span class="p">:</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"plava = "</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">Boje</span><span class="o">::</span><span class="nl">crvena</span> <span class="p">:</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"crvena = "</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">Boje</span><span class="o">::</span><span class="nl">zelena</span> <span class="p">:</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"zelena = "</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_nazivlje">Nazivlje</h3>
<div class="ulist"><ul>
<li>
<p>
<code>enum</code> zovemo <strong>enumeracijom vanjskog dosega</strong> (eng. <em>unscoped enumeration</em>)
</p>
</li>
<li>
<p>
<code>enum class</code> zovemo  <strong>enumeracijom unutarnjeg dosega</strong> (eng. <em>scoped enumeration</em>).
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_eksplicitno_zadavanje_implementacijskog_tipa">Eksplicitno zadavanje  implementacijskog tipa</h3>
<div class="paragraph"><p>U C++11  se implementacijski tip može eksplicitno zadati. Na primjer, u sljedećoj deklaraciji se implicitni
integralni tip definira kao <code>char</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nl">Colors</span> <span class="p">:</span> <span class="kt">char</span> <span class="p">{</span> <span class="n">blue</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span> <span class="p">};</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_anonimne_enumeracije">Anonimne enumeracije</h3>
<div class="paragraph"><p>Enumeracija vanjskog dosega može biti <strong>anonimna</strong>.
Ukoliko ime enumeracije ne koristimo, možemo ga naprosto ispustiti.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="p">{</span> <span class="n">NoEquations</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">NoVariables</span> <span class="o">=</span> <span class="mi">3</span><span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Anonimne enumeracije nisu dozvoljene kod enumeracija unutarnjeg dosega.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_constexpr_code"><code>constexpr</code></h2>
<div class="sectionbody">
<div class="paragraph"><p><strong>Konstantan izraz</strong> je izraz koji se može izračunati za vrijeme kompilacija i čija se
vrijednost ne može promijeniti.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>    <span class="c1">// konstantan izraz</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">xx</span> <span class="o">=</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// konstantan izraz</span>
<span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
<span class="c1">//</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// nije konstantan izraz</span>
</pre></div></div></div>
<div class="paragraph"><p>C++11 nudi ključnu riječ <code>constexpr</code> kojom možemo deklarirati varijable koje
predstavljaju konstantne izraz</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">mm</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>   <span class="c1">// greška - nije konstantan izraz</span>
<span class="k">constexpr</span> <span class="kt">double</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// konstantan izraz</span>
</pre></div></div></div>
<div class="paragraph"><p>Tipovi koji se mogu koristiti u <code>constexpr</code> deklaracijama su  reducirani na
tzv. <em>literalne</em> tipove, odnosno tipove koji su dovoljno jednostavni da mogu primati
vrijednosti dane eksplicitnim konstantama (1,2,<em>a</em>,<em>b</em> itd). U literalne tipove spadaju
svi skalarni tipovi, pokazivači, reference, polja literalnih tipova, agregacije itd.</p></div>
<div class="sect2">
<h3 id="_code_constexpr_code_funkcije"><code>constexpr</code> funkcije</h3>
<div class="paragraph"><p>Funkcija može biti deklarirana <code>constexpr</code> s namjerom da se koristi
u konstantnim izrazima (odnosno da se izračunava za vrijeme kompilacije).</p></div>
<div class="paragraph"><p>Na primjer,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">pow2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">k</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">k</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Zatim ju možemo koristiti za izračun parametra predloška <code>array</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">pow2</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">arr1</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Izraz <code>pow2(4)</code> bit će izračunat za vrijeme
kompilacije i čitava inicijalizacija varijable <code>arr1</code> je ispravna i identična
deklaraciji</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">arr1</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>constexpr</code> funkcije imaju određena ograničenja u odnosu na obične funkcije.
Njihovi argumenti i povratna vrijednost moraju biti <em>literalni</em> tipovi. Pored
toga, budući da se tjelo funkcije izračunava za vrijeme kompilacije, postoje i neka
ograničenja na sadržaj tijela: nisu dozvoljeni <code>try</code>-blokovi, <code>goto</code> naredbe itd.</p></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content"><code>constexpr</code> funkcije su uvedene u standardu C++11 i u njemu
postoje vrlo velika ograničenja na sadržaj tijela <code>constexpr</code> funkcije:
tijelo se može sastojati samo od jedne <code>return</code> naredbe,  no funkcija se može pozivati
rekurzivno. Ta su ograničenja uklonjena u C++14 standardu. Koja ograničenja još uvijek
postoje može se vidjeti na stranici <a href="http://en.cppreference.com/w/cpp/language/constexpr">cppreference.com</a>.</td>
</tr></tbody></table>
</div>
<div class="paragraph"><p>Bitno je svojstvo <code>constexpr</code> funkcije da se <strong>može koristiti i kao obična funkcija</strong>.
Ako  <code>constexpr</code> funkciju
pozovemo s argumentima koji nisu poznati za vrijeme kompilacije tijelo funkcije će biti
izvršeno na normalan način, za vrijeme izvršavanja programa.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">nn</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">nn</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pow2</span><span class="p">(</span><span class="n">nn</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Na taj način ne moramo imati dvije funkcije iste funkcionalnosti — jednu običnu, a
drugu za izračunavanje za vrijeme kompilacije.</p></div>
</div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Version 1.0<br>
Zadnja izmjena
 2019-05-14 10:15:11 CEST
</div>
</div>


</body></html>