<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!-- saved from url=(0089)https://web.math.pmf.unizg.hr/nastava/opepp/Slides/Predavanja/html-noslides/slides-3.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="hr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="generator" content="AsciiDoc 8.6.9">
<title>Kontrola kopiranja</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Kontrola kopiranja</h1>
<span id="author">Mladen Jurak</span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2018-02</span>
</div>
<div id="content">
<div class="sect1">
<h2 id="_elementi_kontrole_kopiranja">Elementi kontrole kopiranja</h2>
<div class="sectionbody">
<div class="paragraph"><p>Svaki puta kada definiramo novi tip tada eksplicitno ili implicitno definiramo njegovo
ponašanje prilikom kopiranja, pridruživanja i pri destrukciji. To činimo
definiranjem sljedećih članova klase:</p></div>
<div class="ulist"><ul>
<li>
<p>
konstruktor kopiranjem (<em>copy-constructor</em>),
</p>
</li>
<li>
<p>
konstruktor premještanjem (<em>move-constructor</em>, C++11),
</p>
</li>
<li>
<p>
operator pridruživanja kopiranjem (<em>copy-assignment operator</em>),
</p>
</li>
<li>
<p>
operator pridruživanja premještanjem (<em>move-assignment operator</em>, C++11),
</p>
</li>
<li>
<p>
destruktor.
</p>
</li>
</ul></div>
<div class="paragraph"><p><em>Konstruktor kopiranjem</em> (CCtor) je konstruktor koji uzima jedan parametar tipa (konstantna)
referenca na tip klase (u kojoj se CCtor nalazi). Koristi se eksplicitno kada se objekt konstruira i inicijalizira
objektom istog tipa, te implicitno  kod prijenosa parametara funkciji i u <code>return</code> naredbi.</p></div>
<div class="paragraph"><p><em>Konstruktor premještanjem</em> (MCtor) djeluje u istim situacijama kao i CCtor, ali samo na <em>desnim</em> vrijednostima.</p></div>
<div class="paragraph"><p><em>Operator pridruživanja kopiranjem</em> (OP-C) objektu s lijeve strane znaka jednakosti
pridružuje vrijednost objekta s desne strane kopiranjem. Objekt na desnoj strani ostaje netaknut.</p></div>
<div class="paragraph"><p><em>Operator pridruživanja premještanjem</em> (OP-P) objektu s lijeve strane znaka jednakosti
pridružuje vrijednost objekta s desne strane. Objekt na desnoj strani predaje svoje resurse
objektu na lijevoj strani i ostaje dobar samo za destrukciju.</p></div>
<div class="paragraph"><p><em>Destruktor</em> se poziva automatski kada objekt izlazi iz dosega ili kad se dinamički
alociran objekt briše iz memorije pomoću <code>delete</code>.</p></div>
<div class="paragraph"><p>Budući da objekt bilo kojeg tipa mora imati mogućnost kopiranja prevodilac će
sintetizirati neke elemente kontrole kopiranja (CCtor, MCtor, OP-C, OP-M i destruktor) ako ih sami ne definiramo.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_konstruktor_kopiranjem">Konstruktor  kopiranjem</h2>
<div class="sectionbody">
<div class="paragraph"><p>Konstruktor kopiranjem ili kraće konstrutor kopije (<em>copy-constructor, CCtor</em>) je  konstruktor koji
kreira objekt kopiranjem objekta istog tipa. Kao argument uzima referencu na objekt istog tipa.</p></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Ako u klasi ne definiramo copy constructor, a u kodu se javlja potreba za njim,
prevodilac će ga sintetizirati.</td>
</tr></tbody></table>
</div>
<div class="sect2">
<h3 id="_kako_djeluje_sintetizirani_cctor">Kako djeluje sintetizirani CCtor?</h3>
<div class="paragraph"><p>Sintetizirani CCtor će izvršiti kopiranje svih <em>nestatičkih</em>
varijabli članica tako što    će</p></div>
<div class="ulist"><ul>
<li>
<p>
kod ugrađenih tipova kopirati varijablu;
</p>
</li>
<li>
<p>
kod članica tipa klase pozvati njihov CCtor da obavi kopiranje (definicija je dakle rekurzivna);
</p>
</li>
<li>
<p>
Ako je <em>polje</em> varijabla članica onda će CCtora obaviti kopiranje polja član-po-član.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pozivanje_cctora">Pozivanje CCtora</h2>
<div class="sectionbody">
<div class="paragraph"><p>Poziva u ovim situacijama:</p></div>
<div class="ulist"><ul>
<li>
<p>
Eksplicitna ili implicitna inicijalizacija jednog objekta objektom istog tipa.
</p>
</li>
<li>
<p>
Kopiranje objekta da bi se predao kao argument funkciji.
</p>
</li>
<li>
<p>
Kopiranje objekta da bi bio vraćen iz funkcije (kroz <em>return</em> naredbu).
</p>
</li>
<li>
<p>
Inicijalizacija elementa u sekvencijalnom spremniku.
</p>
</li>
<li>
<p>
Inicijalizacija elemenata polja iz liste inicijalizatora.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Pogledajmo primjer jednostavne klase <code>MagicNo</code> koja  se može zadovoljiti sa kontrolom kopiranja koju
sintetizira prevodilac.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_primjer">Primjer:</h2>
<div class="sectionbody">
<div class="paragraph"><p>Jednostavna klasa koja definira samo konstruktor. Konstruktor kopiranjem je sintetizirao prevodilac.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MagicNo</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
           <span class="n">data_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
     <span class="p">....</span>
    <span class="k">private</span><span class="o">:</span>
       <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data_name</span><span class="p">;</span>
       <span class="kt">int</span>         <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">//    ....</span>
<span class="n">MagicNo</span> <span class="nf">no1</span><span class="p">(</span><span class="s">"Magic number"</span><span class="p">,</span> <span class="mi">117</span><span class="p">);</span> <span class="c1">// Poziv konstruktoru</span>
<span class="n">MagicNo</span> <span class="nf">no2</span><span class="p">(</span><span class="n">no1</span><span class="p">);</span>                 <span class="c1">// Poziv konstruktoru kopije</span>
<span class="n">MagicNo</span> <span class="n">no3</span> <span class="o">=</span> <span class="n">no2</span><span class="p">;</span>                <span class="c1">// Poziv konstruktoru kopije</span>
</pre></div></div></div>
<div class="paragraph"><p>Nakon definicije klase definirali smo tri objekta tipa
<code>MagicNo</code>.
Prvi je konstruiran konstruktorom koji uzima dva parametra. Drugi i treći su konstruirani CCtorom;
<code>no2</code> je kopija <code>no1</code>, a <code>no3</code> je kopija <code>no2</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_definicija_cctora">Definicija CCtora</h2>
<div class="sectionbody">
<div class="paragraph"><p>Definirajmo u klasi
<code>MagicNo</code> jedan CCtor koji se ponaša isto kao i sintetizirani, te jedan konstruktor
koji uzima jedan argument tipa <code>int</code> i koji se može koristiti u implicitnim konverzijama:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>


<span class="k">class</span> <span class="nc">MagicNo</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span><span class="n">data_name</span><span class="p">(</span><span class="s">"NoName"</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1">// Ctor1</span>
         <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ctor1"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>         <span class="c1">// Ctor2</span>
           <span class="n">data_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ctor2"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>  <span class="c1">// CCtor</span>
    <span class="k">private</span><span class="o">:</span>
       <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data_name</span><span class="p">;</span>
       <span class="kt">int</span>         <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// u .cpp datoteci</span>
 <span class="n">MagicNo</span><span class="o">::</span><span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span><span class="o">:</span>
     <span class="n">data_name</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">data_name</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CCtor"</span><span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_prijenos_parametara_po_vrijednosti">Prijenos parametara po vrijednosti</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Prijenos argumenta tipa klase <em>"po vrijednosti"</em> vrši se tako što
CCtor napravi kopiju stvarnog argumenta i taj se privremeni objekt predaje funkciji.
Nakon što izađemo iz dosega funkcije privremeni objekt se uništava i pri tome se zove
destruktor klase.
</p>
</li>
<li>
<p>
Kod vraćanja povratne vrijednosti u <em>return</em> naredbi <em>"po vrijednosti"</em>
postupak je analogan: prvo CCtor kreira
jedan privremeni objekt koji se vraća pozivatelju funkcije primjenom operatora pridruživanja,
a onda se privremeni objekt uništava.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Primjer</strong>: Imamo funkciju:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="nf">f</span><span class="p">(</span><span class="n">MagicNo</span> <span class="n">A</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Unutar funkcije f "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="k">return</span> <span class="n">A</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>i poziv:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">no1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">no2</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Dešava se sljedeće:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>no2</code> se kopira u lokanu varijablu <code>A</code> pomoću CCtor-a;
</p>
</li>
<li>
<p>
U <code>return</code> naredbi lokalna varijabla <code>A</code> se kopira pomoću CCtor-a
u privremeni bezimeni objekt;
</p>
</li>
<li>
<p>
Privremeni bezimeni objekt se pomoću operatora pridruživanja (<code>=</code>) pridružuje varijabli <code>no1</code>;
</p>
</li>
<li>
<p>
Dva privremena objekta se uništavaju pozivima destruktoru.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_optimizacija_prevodioca_em_copy_elision_em">Optimizacija prevodioca (<em>copy elision</em>)</h2>
<div class="sectionbody">
<div class="paragraph"><p>Što se dešava u ovoj liniji koda?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="n">no4</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Prvo se poziva Ctor s jedim argumentom (<code>3</code>) i kreira se privremeni objekt. Zatim se poziva CCtor
koji kreira <code>no4</code>. U ovakvoj situaciji prevodioc može izbjeći konstrukciju privremenog
objekta i konstruirati  <code>no4</code> direktno pomoću  poziva Ctor-u s jednim argumentom.
Prevodioci to redovito rade. Efekt je kao da smo napisali:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span> <span class="n">MagicNo</span> <span class="nf">no4</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Primjer</strong>.
U čemu je razlika ako pozovemo funkciju</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="nf">f</span><span class="p">(</span><span class="n">MagicNo</span> <span class="n">A</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>na ovaj način:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">no1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">no2</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>ili na ovaj način:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="n">no5</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">no2</span><span class="p">);</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
U drugom slučaju će elizija kopiranja (<em>copy elision</em>) dozvoliti da je izbjegne konstrukcija privremenog objekta
    u <code>return</code> naredbi  i da se povratna vrijednost direktno konstruira u <code>no5</code>.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">g++ ima opciju <code>-fno-elide-constructors</code> pomoću koje se optimizacija konstruktora može spriječiti.</td>
</tr></tbody></table>
</div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">U osnovi kad se vraća lokalni objekt u <code>return</code> naredbi kao u prethodnom primjeru
            prevodilac može izbjeći korištenje
            konstruktora kopije i direktno konstruirati objekt u memoriji rezerviranoj za dolazni objekt
            (no ta optimizacija ovisi o prevodiocu).</td>
</tr></tbody></table>
</div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">U standardu C++-17 elizija kopiranja je postala obavezna u ovakvim situacijama i više nije
            optimizacija prevodioca.</td>
</tr></tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prijenos_parametra_po_referenci">Prijenos parametra po referenci</h2>
<div class="sectionbody">
<div class="paragraph"><p>Želimo li izbjeći nepotrebne pozive CCtoru i destruktoru treba parametar funkciji predati
<em>"po referenci"</em>. Budući da se stvarni argument pri tome ne kopira nema niti poziva CCtoru i Dtoru.
Ako definiramo</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="nf">g</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">A</span><span class="p">)</span>
<span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Unutar funkcije g "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="k">return</span> <span class="n">A</span><span class="p">;}</span>
</pre></div></div></div>
<div class="paragraph"><p>Sada kod</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pozivam f"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">no2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">no1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"f gotov"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Pozivam g"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">no2</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">no1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"g gotov"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>daje</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Pozivam</span> <span class="n">f</span>
<span class="n">CCtor</span>
<span class="n">Unutar</span> <span class="n">funkcije</span> <span class="n">f</span>
<span class="n">CCtor</span>
<span class="k">operator</span> <span class="o">=</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">f</span> <span class="n">gotov</span>
<span class="n">Pozivam</span> <span class="n">g</span>
<span class="n">Unutar</span> <span class="n">funkcije</span> <span class="n">g</span>
<span class="n">CCtor</span>
<span class="k">operator</span> <span class="o">=</span>
<span class="n">Dtor</span>
<span class="n">g</span> <span class="n">gotov</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_kopiranje_povratne_vrijednosti">Kopiranje povratne vrijednosti</h2>
<div class="sectionbody">
<div class="paragraph"><p>Kad se radi o povratnoj vrijednosti ovakva optimizacija nije uvijek moguća. Treba
zapamtiti sljedeće pravilo:</p></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Funkcija nikad ne smije vratiti pokazivač ili referencu na lokalnu varijablu.</td>
</tr></tbody></table>
</div>
<div class="sect2">
<h3 id="_inicijalizacija_spremnika">Inicijalizacija spremnika</h3>
<div class="ulist"><ul>
<li>
<p>
Ako pri inicijalizaciji spremnika zadamo samo broj elemenata, onda se za inicijalizaciju svakog pojedinog
člana spremnika koristi defaultni konstruktor.
</p>
</li>
<li>
<p>
Ako sve elemente inicijaliziramo jednim zadanim elementom,
onda se poziva CCtor.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vector s tri elementa:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MagicNo</span><span class="o">&gt;</span> <span class="n">niz1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">no1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vector s tri elementa + konverzija:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MagicNo</span><span class="o">&gt;</span> <span class="n">niz2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"polje s tri elementa:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">MagicNo</span> <span class="n">niz3</span><span class="p">[]</span> <span class="o">=</span><span class="p">{</span> <span class="n">no1</span><span class="p">,</span> <span class="n">no2</span><span class="p">,</span> <span class="n">no3</span><span class="p">};</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_onemogucavanje_kopiranja">Onemogućavanje kopiranja</h2>
<div class="sectionbody">
<div class="paragraph"><p>Postoje situacije kada ne želimo dozvoliti kopiranje. Objekt tada ne možemo
po vrijednosti predati funkciji niti ga iz nje vratiti. Takvi objekti su na primjer
streamovi iz <em>iostream</em> biblioteke.</p></div>
<div class="paragraph"><p>Onemogućavanje kopiranja je vrlo jednostavno. Imamo dva načina:</p></div>
<div class="ulist"><ul>
<li>
<p>
Novi način (C++11): CCtor treba proglasiti obrisanim pomoću ključne riječi <code>delete</code>:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">B</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">B</span><span class="p">()</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">B</span><span class="p">(</span><span class="n">B</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>  <span class="c1">// CCtor</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Prevodilac će sada javiti grešku (<em>use of deleted function</em>) ukoliko  eksplicitno ili
implicitno pukušamo pozvati CCtor.</p></div>
<div class="ulist"><ul>
<li>
<p>
CCtor treba staviti u privatni dio klase i ne definirati ga.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span><span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// CCtor</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Prevodilac ili linker će sada javiti grešku ako dođe do poziva CCtora.</p></div>
<div class="ulist"><ul>
<li>
<p>
Specifikacija <code>=delete</code> se može koristiti na bilo kojoj funkciji, a ne samo na
konstruktorima. Ne treba ju, naravno, nikad koristiti na destruktoru.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_kopiranje_klase_s_pokazivackom_varijablom_clanicom">Kopiranje klase s pokazivačkom varijablom članicom</h2>
<div class="sectionbody">
<div class="paragraph"><p>Kopiranje postaje problematično u slučaju kada klasa sadrži pokazivač na dnamički alociranu memoriju.
Pogledajmo klasu,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dangle</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Dangle</span><span class="p">(){</span> <span class="n">p</span><span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">Dangle</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// Destruktor. Dealokacija memorije.</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Resurse koje instance klase trebaju osiguravamo i inicijaliziramo u konstruktoru, a oslobađamo u destruktoru.
To je opći princip konstrukcije klasa i naziva se <strong>RAII</strong> (<em>Resource Acquisition Is Initialization</em>).</p></div>
<div class="paragraph"><p>Zamislimo sada situaciju u kojoj kreiramo novi objekt tipa <code>Dangle</code> iz već postojećeg,
pomoću sintetiziranog CCtora:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Dangle</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Dangle</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// Pozovi sintetizirani CCtor</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Nakon što oba objekta izađu iz svog dosega pozivaju se njihovi destruktori, koji pozivaju operator
<code>delete</code> na  pokazivaču objekta. Tu dolazi do dvostrukog pozivanja operatora <code>delete</code> na istom
pokazivaču što predstavlja sigurnu <strong>grešku</strong>!</p></div>
<div class="paragraph"><p>Kako ispravno konstruirati takve klase pokazat ćemo malo kasnije.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_operator_pridruzivanja_kopiranjem">Operator pridruživanja - kopiranjem</h2>
<div class="sectionbody">
<div class="paragraph"><p>Operator pridruživanja mora biti funkcija članica klase. On se brine za pridruživanje
objekata dane klase. Definira se tako da uzima jedan parametar koji je objekt na
desnoj strani naredbe pridruživanja (desni operand); taj je parametar prirodno konstantna referenca na
tip klase. Povratna vrijednost je referenca na tip klase i ona odgovara lijevom operandu — onom kojem se
pridružuje.  Vrijedi pravilo:</p></div>
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Ako u klasi ne definiramo operator pridruživanja, a u kodu se javlja potreba za njim,
prevodilac će ga sintetizirati.</td>
</tr></tbody></table>
</div>
<div class="paragraph"><p><strong>Sintetizirani OP</strong> vrši pridruživanje član po član na  način kompatibilan sa sintetiziranim CCtorom.
Svi ugrađeni tipovi bit će kopirani; polja će biti kopirana član-po-član kao i u CCtoru. Članice
korisničkog tipa pridružuju se pozivanjem operatora pridruživanja iz njihove klase. Taj može
biti eksplicitno definiran ili sintetiziran.</p></div>
<div class="paragraph"><p><strong>Primjer</strong>:
Ovdje  klasi  <code>MagicNo</code> dodajemo operator
pridruživanja koji djeluje kao sintetizirani OP.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_nastavak">Nastavak</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MagicNo</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span><span class="n">data_name</span><span class="p">(</span><span class="s">"NoName"</span><span class="p">),</span>
                                 <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1">// Ctor1</span>
         <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ctor1"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span> <span class="c1">// Ctor2</span>
           <span class="n">data_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
         <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ctor2"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>  <span class="c1">// CCtor</span>

       <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>   <span class="c1">// OP</span>
    <span class="k">private</span><span class="o">:</span>
       <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data_name</span><span class="p">;</span>
       <span class="kt">int</span>           <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// u .cpp datoteci</span>
<span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">MagicNo</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">data_name</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">data_name</span><span class="p">;</span>
     <span class="n">data</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"operator = "</span><span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
     <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_sintaksa">Sintaksa</h2>
<div class="sectionbody">
<div class="paragraph"><p>Sintaksa poziva operatora pridruživanja je prirodna. U liniji</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">no1</span> <span class="o">=</span> <span class="n">no2</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>vrijednost objekta <code>no2</code> pridružuje  se  objektu <code>no1</code>. Ta je sintaksa
samo pokrata za ekvivalentnu sintaksu:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">no1</span><span class="p">.</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">no2</span><span class="p">);</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_op_vraca_nekonstantnu_referencu">OP vraća nekonstantnu referencu</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="nf">no1</span><span class="p">(</span><span class="s">"Number 1"</span><span class="p">,</span> <span class="mi">117</span><span class="p">);</span>
<span class="n">MagicNo</span> <span class="nf">no2</span><span class="p">(</span><span class="s">"Number 2"</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
<span class="n">MagicNo</span> <span class="nf">no3</span><span class="p">(</span><span class="s">"Number 3"</span><span class="p">,</span> <span class="mi">249</span><span class="p">);</span>
<span class="c1">//     ....</span>
<span class="p">(</span><span class="n">no2</span> <span class="o">=</span> <span class="n">no1</span><span class="p">)</span> <span class="o">=</span> <span class="n">no3</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Zadatak</strong>: Što bi se desilo  u gornjem kodu da smo OP definirali tako da vraća objekt umjesto reference?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MagicNo</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>   <span class="c1">// OP, GREŠKA</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_prevodilac_moze_odbiti_sintetizirati_op">Prevodilac može odbiti sintetizirati OP</h2>
<div class="sectionbody">
<div class="paragraph"><p>Pravilo je da će prevodilac sintetizirati OP ako ga nismo definirali.
To pravilo ima iznimaka, tj. postoje situacije u kojima će prevodilac odbiti
sintetizirati OP za nas. To će se desiti u situacijama kada ponašanje sintetiziranog OP
nije jednoznačno.</p></div>
<div class="paragraph"><p>Tri situacije u kojima će prevodilac odbiti sintetizirati OP su sljedeće:</p></div>
<div class="ulist"><ul>
<li>
<p>
klasa ima članicu koja je referenca na objekt ili
</p>
</li>
<li>
<p>
klasa ima konstantnu varijablu članicu ili
</p>
</li>
<li>
<p>
klasa ima članicu koja ima nedostupni (privatni) ili obrisani OP.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>C++11</strong>: U gornjim situacijama prevodilac će sintetizirati <strong>obrisani</strong> OP.
Ukupni efekt je isti, jedino što će prilikom pokušaja korištenja OP prevodilac
javiti da je OP obrisan (<em>deleted</em>).</p></div>
<div class="paragraph"><p>Slično pravilo vrijedi i za <strong>defaultni konstruktor</strong>: Sintetizirani defaultni konstruktor
će biti <strong>obrisan</strong> u sljedećim situacijama:</p></div>
<div class="ulist"><ul>
<li>
<p>
Klasa ima varijablu članicu s obrisanim ili nedostupnim dodijeljenim konstruktorom;
</p>
</li>
<li>
<p>
Klasa ima članicu koja je referenca ali nije inicijalizirana u klasi.
</p>
</li>
<li>
<p>
Klasa ima konstantnu članicu koja nema dodijeljeni konstruktor i nije
inicijalizirana unutar klase.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Konstruktor kopije</strong> će biti sintetiziran kao <strong>obrisan</strong> samo ako klasa ima članicu
koja ima nedostupan/obrisan CCtor pa se ne može kopirati.</p></div>
<div class="paragraph"><p><strong>Destruktor</strong> će biti sintetiziran kao <strong>obrisan</strong> samo ako klasa ima članicu
koja ima nedostupan/obrisan destruktor.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_op_i_cctor_dolaze_u_paru">OP i CCtor dolaze u paru</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ako je zadovoljavajući sintetizirani CCtor, onda je zadovoljavajući i
sintetizirani OP, i obratno. Kada moramo definirati svoj OP onda redovito moramo definirati i CCtor,
i obratno.</p></div>
<div class="paragraph"><p>Pogledajmo na kraju kako bi trebalo korigirati klasu <code>Dangle</code> da postane ispravna:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">NoDangle</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
       <span class="n">NoDangle</span><span class="p">()</span> <span class="o">:</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{}</span>
       <span class="n">NoDangle</span><span class="p">(</span><span class="k">const</span> <span class="n">NoDangle</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">:</span> <span class="n">p</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">))</span> <span class="p">{}</span>
       <span class="n">NoDangle</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NoDangle</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">){</span>
           <span class="k">if</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">p</span> <span class="o">!=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
               <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
               <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">.</span><span class="n">p</span><span class="p">);</span>
           <span class="p">}</span>
           <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="o">~</span><span class="n">NoDangle</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Operator pridruživanja kopira vrijednost na koju pokazivač pokazuje, a ne sam pokazivač (duboko kopiranje).
</p>
</li>
<li>
<p>
Operator pridruživanja  mora brinuti o trivijanom pridruživanju ( <code>a=a</code> ).
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_destruktor">Destruktor</h2>
<div class="sectionbody">
<div class="paragraph"><p>Destruktor je posebna funkcija članica klase
koja se poziva automatski kod
destrukcije objekta.
Zadatak destruktora je osloboditi resurse koje je objekt rezervirao (<em>file handles</em>,
<em>socets</em>, itd.),   osloboditi dinamički alociranu memoriju itd.</p></div>
<div class="ulist"><ul>
<li>
<p>
Destruktor ima isto ime kao i klasa kojem prethodi tilda (<code>~</code>).  Nema povratne vrijednosti i ne uzima parametre.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="_kada_se_poziva_destruktor">Kada se poziva destruktor?</h3>
<div class="ulist"><ul>
<li>
<p>
Kada je doseg objekta lokalan destruktor se poziva u trenutku kada objekt izlazi iz svog dosega.
</p>
</li>
<li>
<p>
Ako je objekt kreiran pomoću operatora <em><code>new</code></em>, destruktor će biti pozvan kad se pozove operator <em><code>delete</code></em>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Važno je uočiti da se destruktor ne poziva kada referenca ili pokazivač izlazi iz
dosega. To se dešava samo kada objekt (a ne referenca)  izlazi iz dosega i
kada se pozove <em><code>delete</code></em> na pokazivaču.</p></div>
<div class="paragraph"><p>Spremnici kao što su polja i STL spremnici uništavaju se kada izlaze iz dosega.
Pri tome, ako su im članovi tipa klase, onda se poziva destruktor na svakom članu
spremnika, u redosljedu suprotnom od onog kojim su elementi konstruirani.
Isti postupak se dešava s dinamički alociranim poljima na kojima
je pozvan <code>delete []</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sintetizirani_destruktor">Sintetizirani destruktor</h2>
<div class="sectionbody">
<div class="admonitionblock">
<table><tbody><tr>
<td class="icon">
<div class="title">Napomena</div>
</td>
<td class="content">Ako ne definiramo vlastiti destruktor prevodilac će uvijek sintetizirati  destruktor
za nas.</td>
</tr></tbody></table>
</div>
<div class="paragraph"><p>Sintetizirani destruktor uništava nestatičke objekte u poretku suprotnom od onog u
kojem su konstruirani, a to znači u poretku suprotnom od onog kojim su  u  klasi deklarirani.
Na svakom članu tipa klase poziva njegov
destruktor.</p></div>
<div class="sect2">
<h3 id="_pisanje_vlastitog_destruktora">Pisanje vlastitog destruktora</h3>
<div class="ulist"><ul>
<li>
<p>
Klase koje ne alociraju resurse (memoriju i druge resurse) ne moraju  definirati
svoj destruktor. Sintetizirani će biti dovoljan da obavi posao.
</p>
</li>
<li>
<p>
<strong>Pravilo trojice</strong>: ako imamo potrebu napisati eksplicitni destruktor, onda moramo napisati
i CCtor i OP.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Primjer</strong> (ovdje nemamo potrebu za destruktorom, samo ilustriramo sintaksu):</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nastavak_2">Nastavak</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MagicNo</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span><span class="n">data_name</span><span class="p">(</span><span class="s">"NoName"</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1">// Ctor1</span>
         <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ctor1"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>         <span class="c1">// Ctor2</span>
           <span class="n">data_name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">data</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ctor2"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

       <span class="n">MagicNo</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>  <span class="c1">// CCtor</span>

       <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MagicNo</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">);</span>

       <span class="o">~</span><span class="n">MagicNo</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dtor"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;}</span>

    <span class="k">private</span><span class="o">:</span>
       <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">data_name</span><span class="p">;</span>
       <span class="kt">int</span>        <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_prazna_klasa_nije_prazna">Prazna klasa nije prazna</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ako definiramo <em>praznu</em> klasu</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Empty</span> <span class="p">{};</span>
</pre></div></div></div>
<div class="paragraph"><p>dobivamo klasu oblika:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Empty</span><span class="p">{</span>
    <span class="n">Empty</span><span class="p">(){...}</span>
    <span class="n">Empty</span><span class="p">(</span><span class="k">const</span> <span class="n">Empty</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){...}</span>
    <span class="o">~</span><span class="n">Empty</span><span class="p">(){...}</span>
    <span class="n">Empty</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Empty</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){...}</span>
<span class="p">};</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_primjer_vektor_varijabilne_duljine_predlozak_klase_code_vec_code">Primjer: Vektor varijabilne duljine: predložak klase <code>Vec</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Predložak  <code>Vec&lt;T&gt;</code> sadržava dinamički
alociran vektor proizvoljne duljine. Polje alociramo dinamički u
konstruktoru, a dealociramo ga u destruktoru. Imamo još jednu dodatnu varijablu <code>mime</code>
koja može predstavljati ime fizičke veličine koju vektor drži.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vect</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">using</span>  <span class="n">Index</span> <span class="o">=</span>  <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">Vect</span><span class="p">(</span><span class="n">Index</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="n">v</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ime</span><span class="o">=</span><span class="s">""</span><span class="p">);</span>
        <span class="o">~</span><span class="n">Vect</span><span class="p">(){</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">mdata</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dtor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">Vect</span><span class="p">(</span><span class="k">const</span> <span class="n">Vect</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>                            <span class="c1">// CCtor</span>
        <span class="n">Vect</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vect</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>                 <span class="c1">// OP</span>

        <span class="n">T</span> <span class="k">operator</span><span class="p">[](</span><span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mdata</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
        <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mdata</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

        <span class="n">Index</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">msize</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">T</span> <span class="n">two_norm</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mime</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">Index</span>   <span class="n">msize</span><span class="p">;</span>
        <span class="n">T</span> <span class="o">*</span><span class="n">mdata</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span>  <span class="n">mime</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_dealokacija">Dealokacija</h2>
<div class="sectionbody">
<div class="paragraph"><p>Dealokacija memorije se dešava kod poziva destruktora, dakle kada objekt izlazi iz dosega ili
kada se pozove <code>delete</code> na dinamički alociranom objektu.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">2.0</span><span class="p">);</span>
    <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">px</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vect</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span><span class="mf">1.9</span><span class="p">);</span>

    <span class="k">delete</span> <span class="n">px</span><span class="p">;</span> <span class="c1">// Poziv destruktor iz klase Vect.</span>
    <span class="c1">// x izlazi iz dosega -&gt; poziv destruktora iz klase Vect.</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Destruktor je dan u samoj klasi (i stoga je implicitno <code>inline</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">Vect</span><span class="p">(){</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">mdata</span><span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dtor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_konstruktor_kopije">Konstruktor kopije</h2>
<div class="sectionbody">
<div class="paragraph"><p>Dizajn konstruktora kopije posve je izravan. Alociramo novu memoriju za vektor i kopiramo
članove iz danog vektora.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Vect</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Vect</span><span class="p">(</span><span class="k">const</span> <span class="n">Vect</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span><span class="o">:</span> <span class="n">msize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">mdata</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()]),</span> <span class="n">mime</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">get_name</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"C-Ctor"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">mdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">.</span><span class="n">mdata</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_operator_pridruzivanja">Operator pridruživanja</h3>
<div class="paragraph"><p>Kod operatora pridruživanja moramo paziti na dvije stvari:</p></div>
<div class="ulist"><ul>
<li>
<p>
Da dealociramo memoriju vektora na lijevoj strani.
</p>
</li>
<li>
<p>
Da dobro tretiramo samopridruživanje.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Vect</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">Vect</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vect</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"OP"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mdata</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">mdata</span><span class="p">)</span> <span class="c1">// Vektori su jednaki ako pokazuju na istu memorijsku lokaciju</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">mdata</span><span class="p">;</span>
        <span class="n">mdata</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">v</span><span class="p">.</span><span class="n">msize</span><span class="p">];</span> <span class="c1">// bad_alloc ako ne uspije</span>
        <span class="n">msize</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">msize</span><span class="p">;</span>
        <span class="n">mime</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">mime</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">Index</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">mdata</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">.</span><span class="n">mdata</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Zadatak</strong>. Implementirajte sve ostale metode iz klase  <code>Vec&lt;T&gt;</code>.
Optimizirajte operator pridruživanja tako da ne dealocira memoriju ako to nije nužno.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_valgrind">Valgrind</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Zaboravimo li smjestiti dealokaciju u destruktor imat ćemo problem <em>gubitka memorije</em> (eng. <em>memory leak</em>). Dinamički
alocirana memorija ne oslobađa se u trenutku kada gubimo pristup do nje već ostaje alocirana do kraja izvršavanja programa.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Gubitak memorije predstavlja ozbiljan problem
u C++ programima. Stoga su razvijeni različiti alati koji ga mogu detektirati.
U Linux okruženju može se  koristiti <em>valgrind</em> program
<a href="http://www.valgrind.org/">http://www.valgrind.org/</a>.
Izvršavanje programa (recimo a.out)  vrši se "kroz" valgrind koji prati izvršavanje programa i
izvještava o greškama u radu s memorijom:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">valgrind</span> <span class="o">--</span><span class="n">tool</span><span class="o">=</span><span class="n">memcheck</span> <span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">yes</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span>
</pre></div></div></div>
<div class="paragraph"><p>Pretpostavimo da smo iz klase <code>Vect</code> uklonili destruktor. Dio poruke koju valgrind daje mogla
bi izgledati ovako:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">==</span><span class="mi">4128</span><span class="o">==</span> <span class="mi">8</span><span class="p">,</span><span class="mi">272</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">3</span> <span class="n">blocks</span> <span class="n">are</span> <span class="n">definitely</span> <span class="n">lost</span> <span class="n">in</span> <span class="n">loss</span> <span class="n">record</span> <span class="mi">1</span> <span class="n">of</span> <span class="mi">1</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>    <span class="n">at</span> <span class="mh">0x4024B9C</span><span class="o">:</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">unsigned</span><span class="p">)</span> <span class="p">(</span><span class="n">vg_replace_malloc</span><span class="p">.</span><span class="nl">c</span><span class="p">:</span><span class="mi">195</span><span class="p">)</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>    <span class="n">by</span> <span class="mh">0x804921C</span><span class="o">:</span> <span class="n">Vect</span><span class="o">::</span><span class="n">Vect</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span> <span class="p">(</span><span class="n">in</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jurak</span><span class="o">/</span><span class="n">mytext</span><span class="o">/</span><span class="p">{</span><span class="n">cxx</span><span class="p">}</span><span class="o">/</span><span class="n">klase</span><span class="o">-</span><span class="n">pr</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">)</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>    <span class="n">by</span> <span class="mh">0x8048B5A</span><span class="o">:</span> <span class="n">main</span> <span class="p">(</span><span class="n">in</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">jurak</span><span class="o">/</span><span class="n">mytext</span><span class="o">/</span><span class="p">{</span><span class="n">cxx</span><span class="p">}</span><span class="o">/</span><span class="n">klase</span><span class="o">-</span><span class="n">pr</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span><span class="p">)</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span> <span class="n">LEAK</span> <span class="nl">SUMMARY</span><span class="p">:</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>    <span class="n">definitely</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span><span class="mi">272</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">3</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>      <span class="n">possibly</span> <span class="nl">lost</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>    <span class="n">still</span> <span class="nl">reachable</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
<span class="o">==</span><span class="mi">4128</span><span class="o">==</span>         <span class="nl">suppressed</span><span class="p">:</span> <span class="mi">0</span> <span class="n">bytes</span> <span class="n">in</span> <span class="mi">0</span> <span class="n">blocks</span><span class="p">.</span>
</pre></div></div></div>
<div class="paragraph"><p>Vidimo da valgrind detektira klasu koja je alocirala memoriju koja nije dealocorana.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_konstrukcija_i_pridruzivanje_premjestanjem_problem">Konstrukcija i pridruživanje premještanjem - problem</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
<strong>Problem</strong>. Kopiranje podataka koje vrše CCtor i OP je nepotrebno (i stoga neefikasno) u slučaju kada
se objekt koji se kopira neposredno nakon toga uništava. Tada je efikasnije (i prirodnije) preuzeti resurse tog objekta umjesto
da ih se kopira   jer će na objektu ionako u sljedećem koraku biti pozvan destruktor. Posao preuzimanja resursa obavljaju
<em>konstruktor kopije premještanjem</em>  i <em>operator pridruživanja premještanjem</em>.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Primjer 1.</strong>  Napravimo prvo mali test program koji mjeri (posredno) vrijeme potrebno za kreiranje i kopiranje lokalnog objekta.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;  // za mjerenje vremena</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">"vector.h"</span><span class="cp"></span>

<span class="c1">// Funkcija koja vraća lokalnu kopiju</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_square</span><span class="p">(</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">in</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="k">typename</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
       <span class="p">{</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="mi">500000</span><span class="p">,</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span> <span class="c1">// Pokreni sat.</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">make_square</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span>
                                      <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
                                              <span class="p">);</span> <span class="c1">// vremenska razlika</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Time for the call = "</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">" micro sec"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// u mikrosekundama</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Rezultat izvršavanja je:</strong></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">OP</span>
<span class="n">Dtor</span>
<span class="n">Time</span> <span class="k">for</span> <span class="n">the</span> <span class="n">call</span> <span class="o">=</span> <span class="mi">6898</span> <span class="n">micro</span> <span class="n">sec</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
</pre></div></div></div>
<div class="paragraph"><p>Ovdje je došlo do elizije CCtora u <code>return</code> naredbi.</p></div>
<div class="paragraph"><p><strong>Napomena</strong>.  Neefikasnost ovog koda je u pozivu operatoru pridruživanja koji kopira vektor <code>y</code>, lokalno definiran unutar
metode <code>make_square</code>, u vektor  <code>y</code> definiran unutar metode <code>main</code>.  Vektor
<code>y</code> iz metode <code>make_square</code> je iskopiran  član po član u vektor  <code>y</code> unutar metode <code>main</code>,
a zatim je uništen prolazom destruktora. Prirodnije je da vektor <code>y</code> unutar metode <code>main</code>
jednostavno preuzme dinamički alociranu memoriju vektora <code>y</code> iz metode <code>make_square</code> jer se na taj način
izbjegava nepotrebna alokacija i dealokacija memorije.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_nastavak_3">Nastavak</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Nepotrebno kopiranje se dešava i u STL spremnicima kao što je <code>std::vector</code> koji dinamički povećavaju svoju
veličinu kada je to potrebno.  Ako u <code>std::vector</code>  pokušamo ubaciti element kada u njemu više nema slobodnih
mjesta on će alocirati novu memoriju dovoljne veličine i prekopirati već postojeće element u nju. To kopiranje je neefikasno
i može se     zamijeniti premještanjem.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Primjer 2</strong>:    Proučite broj poziva konstruktoru kopije i destruktoru u sljedećem kodu:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Vect</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">4.0</span><span class="p">),</span> <span class="n">a2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">a3</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">a4</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">collection</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a3</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a4</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Rezultat</strong>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">Dtor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Objašnjenje</strong>.  Vektor počinje svoj život kao prazan. Kad ubacimo prvi element u njega on alocira
memoriju za jedan element i kopira element u svoju memoriju (poziv C-Ctoru). Kada ubacujemo drugi element
za njega nema mjesta u vektoru. Tada <code>std::vector</code>  alocira memoriju za dva objekta, kopira prvi
element na novu memorijsku lokaciju i zatim kopira novoubačeni element iza prvog elementa. Prvi element na staroj
lokaciji se uništava pozivom destruktora. Kod ubacivanja
trećeg elementa ponovo nema dovoljno mjesta u vektoru i postupak se ponavlja. Sada se alocira memorija za 4
elemenata na novoj lokaciji, prva dva elementa se kopiraju sa stare lokacije i ubacuje se treći element.
Prva dva elementa na staroj lokaciji se uništavaju prolazom destruktora.
Sada za četvrti element imamo slobodno mjesto pa  pri njegovom ubacivanju nema nove realokacije. Jasno je da su
u slučaju objekata (<code>Vect</code>) koji dinamički alociraju memoriju sva ta silna kopiranja nepotrebna i neefikasna.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_konstruktor_kopije_premjestanjem_i_operator_pridruzivanje_premjestanjem">Konstruktor kopije premještanjem i operator pridruživanje premještanjem</h2>
<div class="sectionbody">
<div class="paragraph"><p>Neefikasnost u prehodna dva primjera (i drugim) možemo izbjeći dodavanjem dva nova operatora
svakom tipu kod kojeg premještanje može biti efikasnije od kopiranja.</p></div>
<div class="ulist"><ul>
<li>
<p>
Konstruktor kopije premještanjem (eng. <em>move constructor</em>).
</p>
</li>
<li>
<p>
Operator pridruživanje premještanjem (eng. <em>move assignment operator</em>).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Obje ove funkcije uzimaju argument tipa <strong>desne reference</strong> što znači da djeluju na privremenim bezimenim objektima
koji su na kraju svog životnog vijeka i stoga se njihovi resursi mogu <strong>preuzeti</strong>.</p></div>
<div class="paragraph"><p>Puna kontrola kopiranja u klasi Vect ima ovaj oblik:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Vec</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">using</span>  <span class="n">Index</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>

        <span class="k">explicit</span> <span class="nf">Vect</span><span class="p">(</span><span class="n">Index</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="n">v</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ime</span><span class="o">=</span><span class="s">""</span><span class="p">);</span>

        <span class="o">~</span><span class="n">Vec</span><span class="p">(){</span>  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Dtor"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="k">delete</span> <span class="p">[]</span> <span class="n">mdata</span><span class="p">;}</span>

        <span class="n">Vec</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>                            <span class="c1">// CCtor</span>
        <span class="n">Vec</span><span class="p">(</span><span class="n">Vec</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>                       <span class="c1">// MCtor</span>

        <span class="n">Vec</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">);</span>                 <span class="c1">// OP</span>
        <span class="n">Vec</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vec</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>            <span class="c1">// MOP</span>

       <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Konstruktor kopije premještanjem uzima nekonstantnu referencu na desnu vrijednost. To znači da će prevodilac:
</p>
<div class="ulist"><ul>
<li>
<p>
Pozvati konstruktor kopije <strong>kopiranjem</strong> ako kopira <strong>lijevu</strong> vrijednost;
</p>
</li>
<li>
<p>
Pozvati konstruktor kopije <strong>premještanjem</strong> ako kopira <strong>desnu</strong> vrijednost.
</p>
</li>
</ul></div>
</li>
<li>
<p>
Operator pridruživanja kopiranjem ili premještanjem selektira se na isti način, ovisno o tome je li na
desnoj strani lijeva ili desna vrijednost.
</p>
</li>
<li>
<p>
Da bi se mogli efikasno koristiti sa spremnicima konstruktor kopije i operator pridruživanja <strong>premještanjem</strong>
moraju biti označeni <code>noexcept</code> — što znači da ne izbacuju izuzetke.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_konstruktor_kopije_premjestanjem_implementacija">Konstruktor kopije premještanjem: Implementacija</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Novokreirani vektor preuzima resurse vektora kojeg <em>kopira preuzimanjem</em>.
</p>
</li>
<li>
<p>
Objekte (kao npr. <code>std::string</code>) preuzimamo pomoću <code>std::move</code> funkcije.
</p>
</li>
<li>
<p>
Objekt s desne strane mora ostati u stanju pogodnom za prolaz destruktora (pokazivač obavezno na <code>nullptr</code>).
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Vect</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Vect</span><span class="p">(</span><span class="n">Vect</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">msize</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">msize</span><span class="p">),</span> <span class="n">mdata</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">mdata</span><span class="p">),</span> <span class="n">mime</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">mime</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"M-Ctor"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">msize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">mdata</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_operator_pridruzivanje_premjestanjem_implementacija">Operator pridruživanje premještanjem: Implementacija</h3>
<div class="ulist"><ul>
<li>
<p>
Resursi se preuzimaju na isti način kao i u konstruktoru.
</p>
</li>
<li>
<p>
Moramo paziti na samopridruživanje zbog koda oblika:  <code>x = std::move(x);</code>
</p>
</li>
<li>
<p>
Objekt s desne strane mora ostati u stanju pogodnom za prolaz destruktora (pokazivač obavezno na <code>nullptr</code>).
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Vect</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">Vect</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vect</span> <span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"M-OP"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="c1">// samopridruživanje je moguće ako se koristi std::move</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">mdata</span><span class="p">;</span>
        <span class="n">mdata</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">mdata</span><span class="p">;</span>
        <span class="n">msize</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">msize</span><span class="p">;</span>
        <span class="n">mime</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">mime</span><span class="p">);</span>
        <span class="n">v</span><span class="p">.</span><span class="n">mdata</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">v</span><span class="p">.</span><span class="n">msize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_primjer_1_strong_isti_kao_i_ranije"><strong>Primjer 1</strong>.  Isti  kao i ranije:</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;  // za mjerenje vremena</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_square</span><span class="p">(</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span><span class="p">(</span><span class="k">typename</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
       <span class="p">{</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">(</span><span class="mi">500000</span><span class="p">,</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span> <span class="c1">// Pokreni sat.</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">make_square</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span>
                                      <span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
                                              <span class="p">);</span> <span class="c1">// vremenska razlika</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Time for the call = "</span> <span class="o">&lt;&lt;</span> <span class="n">duration</span><span class="p">.</span><span class="n">count</span><span class="p">()</span><span class="o">&lt;&lt;</span> <span class="s">" micro sec"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// u milisekundama</span>

  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Rezultat izvršavanja je:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">M</span><span class="o">-</span><span class="n">OP</span>
<span class="n">Dtor</span>
<span class="n">Time</span> <span class="k">for</span> <span class="n">the</span> <span class="n">call</span> <span class="o">=</span> <span class="mi">5111</span> <span class="n">micro</span> <span class="n">sec</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
</pre></div></div></div>
<div class="paragraph"><p>Budući da tip koji vraćamo iz funkcije <code>make_square</code>  ima operator pridruživanja premještanjem
on je iskorišten umjesto operatora pridruživanja kopiranjem. Time smo uštedjeli dealokaciju i alokaciju
500000 elemenata tipa <code>double</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_strong_primjer_2_strong_spremanje_u_code_std_vector_code_u_programu"><strong>Primjer 2.</strong>   Spremanje u <code>std::vector</code>: U programu</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Vect</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">4.0</span><span class="p">),</span> <span class="n">a2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">2.0</span><span class="p">),</span> <span class="n">a3</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">a4</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vect</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">collection</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a3</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ubaci element:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">collection</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">a4</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"capacity = "</span> <span class="o">&lt;&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>sada dobivamo sljedeći rezultat iz kojeg je vidljivo da vektor vrši realokaciju pomoću
konstruktora kopije premještanjem:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">Ctor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">M</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">Dtor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">M</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">M</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">Ubaci</span> <span class="nl">element</span><span class="p">:</span>
<span class="n">C</span><span class="o">-</span><span class="n">Ctor</span>
<span class="n">capacity</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
<span class="n">Dtor</span>
</pre></div></div></div>
<div class="paragraph"><p>Iz ispisa vidimo da pri premještanju starih elemenata na nove lokacije <code>std::vector</code> koristi
operator pridruživanja premještanjem i na taj način štedi na alokaciji i dealokaciji memorije.</p></div>
<div class="paragraph"><p><strong>Napomena</strong>: <code>std::vector</code> garantira da polazni vektor neće biti
promijenjen ako realokacija elemenata ne uspije. To je lako osigurati s kopiranjem jer kopiranje ne mijenja polaznu vrijednost.
Da bi se moglo
osigurati s premještanjem, konstruktor kopije premještanjem i operator pridruživanja premještanjem moraju
garantirati da neće izbaciti izuzetak.
Ukoliko nema takve garancije  <code>std::vector</code> će pri realokaciji koristiti  konstruktor kopije <em>kopiranjem</em> i
operator pridruživanja <em>kopiranjem</em>.
Zbog toga operatori premještanjem moraju biti deklarirani <code>noexcept</code> ukoliko želimo da budu efikasno iskorišteni.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_zakljucci_sintetizirano_premjestanje">Zaključci, sintetizirano premještanje:</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Mehanizam koji omogućava kontrolu kopiranja kopiranjem-premještanjem je preopterećenje
funkcija u odnosu na lijevu i desnu referencu. Pri tome uvijek kombiniramo funkciju koja
uzima konstantnu lijevu referencu i nekonstantnu desnu referencu.
</p>
</li>
<li>
<p>
Ako konstruktor kopije ili operator pridruživanja ne postoje u verziji s premještanjem
koristi se verzija s kopiranjem (jer se konstantna lijeva referenca može inicijalizirati desnom vrijednošću).
</p>
</li>
<li>
<p>
I sve druge funkcije se mogu preopteretiti po smislu reference (lijeva/desna), posebno i
druge članice klase pored CCtor-a i OP.
</p>
</li>
<li>
<p>
<code>std::move</code> treba koristiti vrlo racionalno je  o stanju objekta nakon što je <em>pomaknut</em>
znamo samo da je dobar za destrukciju.
</p>
</li>
<li>
<p>
Prevodilac sintetizira konstruktor i OP premještanjem samo ako klasa ne definira niti jedan član kontrole
kopiranja i ako sve varijable članice mogu biti konstruirane premještanjem odnosno pridružene premještanjem.
</p>
</li>
<li>
<p>
Ako eksplicitno zatražimo sintetiziranje operacija premještanjem pomoću <code>= default</code>, a prevodilac
nije u mogućnosti premjestiti članove klase, operacija premještanjem će biti definirana  <code>deleted</code>.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_jos_o_povratnoj_vrijednosti_funkcije">Još o povratnoj vrijednosti funkcije</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Ima li smisla definirati funkciju tako da vraća desnu referencu?
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Vect</span> <span class="o">&amp;&amp;</span>  <span class="n">f</span><span class="p">(</span><span class="n">Vect</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">Vect</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Vect</span> <span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>       <span class="c1">// Greška</span>
<span class="n">Vect</span> <span class="o">&amp;&amp;</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>   <span class="c1">// Greška</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Ako funkcija vraća referencu na lokalnu varijablu to je greška (kao u slučaju da vraća lijevu referencu).
  Lokalni objekt je uništen prije povratka u pozivni program.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Jedina mogućnost takvog koda je ovog tipa:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Vect</span> <span class="o">&amp;&amp;</span>  <span class="n">g</span><span class="p">(</span><span class="n">Vect</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">){</span>
        <span class="n">x</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>  <span class="c1">// OK</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Treba li koristiti <code>std::move()</code> pri povratu lokalnog objekta?
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Vect</span> <span class="nf">f</span><span class="p">(</span><span class="n">Vect</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">){</span>
     <span class="n">Vect</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">Vect</span> <span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Odgovor je NE. Prevodilac ima pravo primijeniti operator kopiranja premještanjem na lokalnu
varijablu i <code>std::move()</code> je suvišan. Štoviše, <code>std::move()</code> će spriječiti optimizaciju povratne
vrijednosti koja može ponekad eliminrati i kopiranje i premještanje.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_klase_s_pokazivacima">Klase s pokazivačima</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_problem">Problem</h3>
<div class="paragraph"><p>Programski jezik C++ nema <em>sakupljača smeća</em> (eng. <em>garbage collector</em>) kao neki drugi jezici (npr. Java)
i stoga programer mora brinuti o dealokaciji dinamički alocirane memorije.
Sljedeći primjer pokazuje jednu <em>factory</em> metodu. To je metoda koja
dinamički alocira objekt i vraća pokazivač na njega.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BFC</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">explicit</span> <span class="n">BFC</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">aa</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{}</span>
        <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">aa</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">aa</span><span class="o">=</span><span class="n">a</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// .......</span>
        <span class="o">~</span><span class="n">BFC</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"BFC("</span> <span class="o">&lt;&lt;</span> <span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">") is dead."</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">aa</span><span class="p">;</span>
        <span class="c1">// ....</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">BFC</span> <span class="o">*</span> <span class="nf">factoryBFC</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="c1">// Dinamički alociramo objekt</span>
    <span class="n">BFC</span> <span class="o">*</span> <span class="n">pbfc</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BFC</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="c1">// Vraćamo pokazivač na dinamički alociran objekt</span>
    <span class="k">return</span> <span class="n">pbfc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problem_moramo_brinuti_o_dealokaciji">Problem - moramo brinuti o dealokaciji</h2>
<div class="sectionbody">
<div class="paragraph"><p>Odgovornost je pozivnog programa da
dealocira memoriju kada je gotov s objektom koji je dobio od <em>factory</em> metode.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">BFC</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">factoryBFC</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">BFC</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">factoryBFC</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="c1">// ....</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b = "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Dealociram memoriju alociranu u factoryBFC</span>
    <span class="k">delete</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// Zaboravio uništiti b ! -- memory leak</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Dinamičko alociranje objekata je često te je potrebno naći sustavno rješenje za dealokaciju.
</p>
</li>
<li>
<p>
<strong>Rješenje  problema:</strong> <em>Pokazivač treba smjestiti unutar klase čiji
destruktor poziva <code>delete</code> na pokazivaču</em>. Kada takav objekt izađe iz dosega
automatski se poziva destruktor koji dealocira objekt na koji pokazivač referira. Na taj način
ne moramo brinuti o dealokaciji memorije.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Napomena</strong>. Ovo rješenje je primjer programskog principa koji se naziva
<em>Resource Acquisition Is Initialization</em> (RAII). Prema tom principu objekt prikuplja potrebne resurse u
konstruktoru, a oslobađa ih u destruktoru, što automatizira oslobađanje resursa.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_unique_ptr_lt_t_gt">unique_ptr&lt;T&gt;</h2>
<div class="sectionbody">
<div class="paragraph"><p>Standardna biblioteka nam nudi  klasu <code>unique_ptr&lt;T&gt;</code>
koju možemo koristiti za sprečavanje gubljenja memorije. Dekarirana je u
zaglavlju <code>&lt;memory&gt;</code>.</p></div>
<div class="paragraph"><p>Klasu koristimo na sljedeći način: Ako imamo pokazivač na tip <code>T</code> za koji želimo da se
automatski  dealocira pri izlasku iz dosega predajemo ga konstruktoru klase
<code>unique_ptr&lt;T&gt;</code>.</p></div>
<div class="paragraph"><p>Objekt klase  <code>unique_ptr&lt;T&gt;</code> koristimo na isti
način kao i pokazivač. To je moguće stoga što je klasa <code>unique_ptr&lt;T&gt;</code>
tzv. pokazivački objekt, odnosno u njoj su preopterećeni  operatori <code>*</code> i <code>-&gt;</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BFC</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span> <span class="n">factoryBFC</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">);</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">BFC</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span> <span class="n">factoryBFC</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">);</span>
    <span class="c1">// ....</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b = "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Dealokacija memorije je sada automatska</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Na izlasku iz funkcije <code>f()</code>
više ne moramo     brinuti o dealokaciji memorije. Nju će obaviti destruktor klase
<code>unique_ptr&lt;BFC&gt;</code> koji poziva <code>delete</code> na pokazivaču.</p></div>
<div class="sect2">
<h3 id="_pametni_pokazivac">Pametni pokazivač</h3>
<div class="paragraph"><p>Objekt koji možemo koristiti kao pokazivač (dereferencirati ga i primijeniti operator → na njega)
naziva se <strong>pametni pokazivač</strong>. Pametan je jer obično ima dodatne sposobnosti koje pokazivači nemaju.
Kažemo još da su pametni pokazivači objekti sa <em>semantikom pokazivača</em>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unique_ptr_lt_t_gt_i_kopiranje">unique_ptr&lt;T&gt; i kopiranje</h2>
<div class="sectionbody">
<div class="paragraph"><p>Klasa  <code>unique_ptr&lt;T&gt;</code>
implementira koncept <strong>ekskluzivnog vlasništva nad objektom</strong>.</p></div>
<div class="ulist"><ul>
<li>
<p>
Može postojati samo samo jedan <code>unique_ptr&lt;T&gt;</code> koji drži zadani pokazivač na <code>T</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>To se postiže time što  <code>unique_ptr&lt;T&gt;</code> <em>nema konstruktora kopije kopiranjem niti
operatora pridruživanja kopiranjem</em>.</p></div>
<div class="sect2">
<h3 id="_konstrukcija">Konstrukcija</h3>
<div class="ulist"><ul>
<li>
<p>
Dodijeljeni konstruktor kreira neinicijalizirani pametni pokazivač (onaj koji drži <code>nullptr</code>).
</p>
</li>
<li>
<p>
Operator konverzije u <code>bool</code> dozvoljava ispitivanje je li objekt prazan ili drži netrivijalni pokazivač.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up1</span><span class="p">,</span> <span class="n">up11</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span>  <span class="c1">// objekti bez pokazivača</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">up2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*up2 = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">up2</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">up1</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*up1 = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">up1</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"up1 je prazan.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Ako se ivrši premještanje pametnog pokazivača, pokazivač na desnoj strani prepušta resurs pokazivaču na
lijevoj strani. Pokazivač na lijevoj strani prijue toga oslobađa svoj resurse (poziva <code>delete</code> na svom pokazivaču).
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">up1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">up2</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">up2</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Ekvivalentan kod je</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">up1</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">up2</span><span class="p">.</span><span class="n">release</span><span class="p">());</span>
<span class="n">assert</span><span class="p">(</span><span class="n">up2</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Imamo sljedeće metode:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Poziv   </th>
<th align="left" valign="top"> Značenje</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>a.get()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća pokazivač koji <code>a</code> drži.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.release()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća pokazivač koji drži <code>a</code> i interno postavlja svoj pokazivač na nul-pokazivač. Objekt
<code>a</code> se time odrekao vlasništva koje mora prihvatiti drugi objekt (varijabla ili pametni pokazivač).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.reset()</code></p></td>
<td align="left" valign="top"><p class="table">Briše objekt na koji <code>a</code> pokazuje.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.reset(p)</code></p></td>
<td align="left" valign="top"><p class="table">Briše objekt na koji <code>a</code> pokazuje i inicijalizira svoj pokazivač sa <code>p</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unique_ptr_lt_t_gt_i_funkcije">unique_ptr&lt;T&gt; i funkcije</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Funkcija koja uzima <code>std::unique_ptr&lt;&gt;</code> po vrijednosti preuzima vlasništvo nad objektom. Pri pozivu
  moramo koristiti <code>std::move()</code>.
</p>
</li>
<li>
<p>
Funkcija koja samo manipulira sa objektom može to raditi kroz <em>goli pokazivač</em>. Treba samo slijediti
  konvenciju da goli pokazivač indicira da funkcija nije vlasnik objekta.
</p>
</li>
<li>
<p>
Funkcija koja kreira i vraća  <code>std::unique_ptr&lt;&gt;</code> odriče se vlasništva nad kreiranim objektom.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Funkcija konzumira i uništava UP.</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"pi drži adresu "</span> <span class="o">&lt;&lt;</span>  <span class="n">pi</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Funkcija prima goli pokazivač, što znači da NIJE vlasnik objekta.</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"pi drži adresu "</span> <span class="o">&lt;&lt;</span>  <span class="n">pi</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Funkcija se odriče vlasništva nad UPom.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
          <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="n">pn</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
          <span class="k">return</span> <span class="n">pn</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Te funkcije koristimo na ovaj način:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">up1</span><span class="p">));</span>  <span class="c1">// umjesto CCtora koristimo M-Ctor</span>
<span class="n">assert</span><span class="p">(</span><span class="n">up1</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>

<span class="n">f</span><span class="p">(</span><span class="n">up2</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>  <span class="c1">// predaj goli pokazivač</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">up2</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>

<span class="n">up2</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">up2</span> <span class="o">==</span> <span class="mi">5</span><span class="p">);</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_unique_ptr_lt_t_gt_kao_clanica_klase">unique_ptr&lt;T&gt; kao članica klase</h2>
<div class="sectionbody">
<div class="paragraph"><p>Običan pokazivač na dinamički alociranu memoriju unutar klase ima ovaj nedostatak:</p></div>
<div class="ulist"><ul>
<li>
<p>
Ako je izuzetak izbačen u konstruktoru prije no što je cijeli objekt izgrađen, destruktor se ne
  poziva. Pozivaju se destruktori  samo onih članica klase koje su izgrađene.
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>unique_ptr&lt;T&gt;</code> kao članica klase umjesto golog pokazivača garantira da će memorija biti dealocirana
i ako je izbačen izuzetak u konstruktoru. Problem je tada sljedeći:</p></div>
<div class="ulist"><ul>
<li>
<p>
Ako u klasi držimo <code>unique_ptr&lt;T&gt;</code> moramo implementirati kopiranje i pridruživanje.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span><span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="n">pi</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">pc</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
        <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">pi</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">pc</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{}</span>
        <span class="n">X</span><span class="p">(</span><span class="n">X</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">pi</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">.</span><span class="n">pi</span><span class="p">)),</span> <span class="n">pc</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">.</span><span class="n">pc</span><span class="p">))</span> <span class="p">{}</span>
        <span class="n">X</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">X</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">){</span>
                <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">.</span><span class="n">pi</span><span class="p">;</span> <span class="c1">// duboko kopiranje</span>
                <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="o">*</span><span class="n">x</span><span class="p">.</span><span class="n">pc</span><span class="p">;</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// destruktor nije potreban</span>
<span class="p">};</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_unique_ptr_lt_t_gt_i_polja">unique_ptr&lt;T&gt; i polja</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Destruktor u  <code>unique_ptr&lt;T&gt;</code> poziva <code>delete</code> operator, a ne
<code>delete []</code> operator. Stoga se ne koristi sa dinamički alociranim poljima.
</p>
</li>
<li>
<p>
Kada želimo imati <code>unique_ptr</code> koji pokazuje na dinamički alocirano polje treba
  koristiti klasu <code>unique_ptr&lt;T[]&gt;</code>.
  Tadada možemo  koristiti operator uglatih zagrada (<code>[]</code>), ali ne postoje operatori
  <code>*</code> i <code>-&gt;</code>.  Na primjer:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">polje</span><span class="p">(</span><span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
<span class="n">polje</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">17.0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Adresa  polja = "</span> <span class="o">&lt;&lt;</span> <span class="n">polje</span><span class="p">.</span><span class="n">get</span><span class="p">()</span>
          <span class="o">&lt;&lt;</span> <span class="s">"; polje[3] = "</span> <span class="o">&lt;&lt;</span> <span class="n">polje</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_unique_ptr_lt_t_gt_zavrsne_napomene">unique_ptr&lt;T&gt;. Završne napomene</h2>
<div class="sectionbody">
<div class="paragraph"><p>Klasa  <code>unique_ptr&lt;T&gt;</code> ima dodatni argument predloška koji ima dodijeljenu vrijednost.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="c1">// primary template:</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">D</span> <span class="o">=</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">unique_ptr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="p">...</span>
<span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Klasa <code>default_delete&lt;T&gt;</code> poziva <code>delete</code> na pokazivaču. Zadavanjem parametra <code>D</code> to je ponašanje
moguće izmijeniti.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>unique_ptr&lt;T&gt;</code> nam garantira da nikad neće postojati drugi pametni pokazivač koji
drži isti pokazivač. Taj je pokazivač jedinstven i garantirana je dealokacija memorije kad izađe iz dosega.
<code>unique_ptr&lt;T&gt;</code> implementira <strong>vlasničku semantiku</strong>.
</p>
</li>
<li>
<p>
Klasa <code>unique_ptr&lt;T&gt;</code> uvedena je u standardnu biblioteku standardizacijom iz 2011. godine.
Prije toga je istu ulogu vršila klasa <code>auto_ptr&lt;T&gt;</code> koja i danas postoji u standardnoj biblioteci,
no ne treba ju koristiti.
</p>
</li>
<li>
<p>
Objekte tipa  <code>unique_ptr&lt;T&gt;</code> možemo stavljati u STL spremnike,
za razliku od <code>auto_ptr&lt;T&gt;</code> objekata koje ne možemo.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_brojanje_referenci">Brojanje referenci</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ponekad, radi efikasnosti, imamo više pokazivača koji referiraju na isti objekt.
Kada trebamo novu kopiju samo kopiramo pokazivač.</p></div>
<div class="paragraph"><p>Kada je takvo ponašanje poželjno
onda trebamo riješiti problem višestruke dealokacije objekta. Ponovo ćemo pokazivač
zatvoriti u jednu klasu no u destruktoru klase nećemo nužno pozivati <code>delete</code> na
pokazivaču. Tek kada posljednji pokazivač na objekt izlazi iz dosega, i ne ostaje niti
jedan koji referira na dani objekt, zovemo <code>delete</code>.</p></div>
<div class="paragraph"><p>Tehnika koja nam omogućava držanje više pametnih pokazivača s adresom istog objekta
zove se <em>brojanje referenci</em> i implementirana je u ovoj klasi:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SmartBFC</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">SmartBFC</span><span class="p">(</span><span class="n">BFC</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">cnt</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{}</span>
        <span class="n">SmartBFC</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartBFC</span> <span class="o">&amp;</span> <span class="n">orig</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">ptr</span><span class="p">),</span> <span class="n">cnt</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span>
                                       <span class="p">{</span> <span class="o">++*</span><span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">SmartBFC</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartBFC</span><span class="o">&amp;</span><span class="p">);</span>
        <span class="o">~</span><span class="n">SmartBFC</span><span class="p">(){</span> <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="k">delete</span> <span class="n">cnt</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>

        <span class="c1">// Pomoćne funkcije</span>
        <span class="k">const</span> <span class="n">BFC</span> <span class="o">*</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">int</span>         <span class="n">use_count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
         <span class="n">BFC</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
         <span class="kt">int</span> <span class="o">*</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Naša implementacija dinamički alocira brojač referenci:</p></div>
<div class="imageblock">
<div class="content">
<img alt="brojanje_ref.png" src="data:image/png;base64,%0AiVBORw0KGgoAAAANSUhEUgAAAhcAAAEACAIAAACPgMOhAAAJNmlDQ1BkZWZhdWx0X3JnYi5pY2MA%0AAHiclZFnUJSHFobP933bCwvssnRYepMqZQHpvUmvogJL7yxLEbEhYgQiiog0RZCggAGjUiRWRLEQ%0AFBSxoFkkCCgxGEVUUPLDOxPn3vHHfX49884755yZA0ARBQBARQFSUgV8Pxd7TkhoGAe+IZKXmW7n%0A4+MJ3+X9KCAAAPdWfb/zXSjRMZk8AFgGgHxeOl8AgOQCgGaOIF0AgBwFAFZUUroAADkLACx+SGgY%0AAHIDAFhxX30cAFhRX30eAFj8AD8HABQHQKLFfeNR3/h/9gIAKNvxBQmxMbkc/7RYQU4kP4aT6edi%0Az3FzcOD48NNiE5Jjvjn4/yp/B0FMrgAAwCEtfRM/IS5ewPmfoUYGhobw7y/e+gICAAh78L//AwDf%0A9NIaAbgLANi+f7OoaoDuXQBSj//NVI8CMAoBuu7wsvjZXzMcAAAeKMAAFkiDAqiAJuiCEZiBJdiC%0AE7iDNwRAKGwAHsRDCvAhB/JhBxRBCeyDg1AD9dAELdAOp6EbzsMVuA634S6MwhMQwhS8gnl4D0sI%0AghAROsJEpBFFRA3RQYwQLmKNOCGeiB8SikQgcUgqkoXkIzuREqQcqUEakBbkF+QccgW5iQwjj5AJ%0AZBb5G/mEYigNZaHyqDqqj3JRO9QDDUDXo3FoBpqHFqJ70Sq0ET2JdqFX0NvoKCpEX6ELGGBUjI0p%0AYboYF3PAvLEwLBbjY1uxYqwSa8TasV5sALuHCbE57COOgGPiODhdnCXOFReI4+EycFtxpbga3Alc%0AF64fdw83gZvHfcHT8XJ4HbwF3g0fgo/D5+CL8JX4Znwn/hp+FD+Ff08gENgEDYIZwZUQSkgkbCaU%0AEg4TOgiXCcOEScICkUiUJuoQrYjexEiigFhErCaeJF4ijhCniB9IVJIiyYjkTAojpZIKSJWkVtJF%0A0ghpmrREFiWrkS3I3uRo8iZyGbmJ3Eu+Q54iL1HEKBoUK0oAJZGyg1JFaadco4xT3lKpVGWqOdWX%0AmkDdTq2inqLeoE5QP9LEado0B1o4LYu2l3acdpn2iPaWTqer023pYXQBfS+9hX6V/oz+QYQpoifi%0AJhItsk2kVqRLZETkNYPMUGPYMTYw8hiVjDOMO4w5UbKouqiDaKToVtFa0XOiY6ILYkwxQzFvsRSx%0AUrFWsZtiM+JEcXVxJ/Fo8ULxY+JXxSeZGFOF6cDkMXcym5jXmFMsAkuD5cZKZJWwfmYNseYlxCWM%0AJYIkciVqJS5ICNkYW53txk5ml7FPsx+wP0nKS9pJxkjukWyXHJFclJKVspWKkSqW6pAalfokzZF2%0Akk6S3i/dLf1UBiejLeMrkyNzROaazJwsS9ZSlidbLHta9rEcKqct5ye3We6Y3KDcgryCvIt8uny1%0A/FX5OQW2gq1CokKFwkWFWUWmorVigmKF4iXFlxwJjh0nmVPF6efMK8kpuSplKTUoDSktKWsoByoX%0AKHcoP1WhqHBVYlUqVPpU5lUVVb1U81XbVB+rkdW4avFqh9QG1BbVNdSD1Xerd6vPaEhpuGnkabRp%0AjGvSNW00MzQbNe9rEbS4Wklah7XuaqPaJtrx2rXad3RQHVOdBJ3DOsOr8KvMV6Wualw1pkvTtdPN%0A1m3TndBj63nqFeh1673WV9UP09+vP6D/xcDEINmgyeCJobihu2GBYa/h30baRjyjWqP7q+mrnVdv%0AW92z+o2xjnGM8RHjhyZMEy+T3SZ9Jp9NzUz5pu2ms2aqZhFmdWZjXBbXh1vKvWGON7c332Z+3vyj%0AhamFwOK0xV+WupZJlq2WM2s01sSsaVozaaVsFWnVYCW05lhHWB+1Ftoo2UTaNNo8t1WxjbZttp22%0A07JLtDtp99rewJ5v32m/6GDhsMXhsiPm6OJY7DjkJO4U6FTj9MxZ2TnOuc153sXEZbPLZVe8q4fr%0AftcxN3k3nluL27y7mfsW934Pmoe/R43Hc09tT75nrxfq5e51wGt8rdra1LXd3uDt5n3A+6mPhk+G%0Az6++BF8f31rfF36Gfvl+A/5M/43+rf7vA+wDygKeBGoGZgX2BTGCwoNaghaDHYPLg4Uh+iFbQm6H%0AyoQmhPaEEcOCwprDFtY5rTu4bircJLwo/MF6jfW5629ukNmQvOHCRsbGyI1nIvARwRGtEcuR3pGN%0AkQtRblF1UfM8B94h3qto2+iK6NkYq5jymOlYq9jy2Jk4q7gDcbPxNvGV8XMJDgk1CW8SXRPrExeT%0AvJOOJ60kByd3pJBSIlLOpYqnJqX2pymk5aYNp+ukF6ULMywyDmbM8z34zZlI5vrMHgFLkC4YzNLM%0A2pU1kW2dXZv9ISco50yuWG5q7uAm7U17Nk3nOef9tBm3mbe5L18pf0f+xBa7LQ1bka1RW/u2qWwr%0A3Da13WX7iR2UHUk7fiswKCgveLczeGdvoXzh9sLJXS672opEivhFY7std9f/gPsh4YehPav3VO/5%0AUhxdfKvEoKSyZLmUV3rrR8Mfq35c2Ru7d6jMtOzIPsK+1H0P9tvsP1EuVp5XPnnA60BXBaeiuOLd%0AwY0Hb1YaV9YfohzKOiSs8qzqqVat3le9XBNfM1prX9tRJ1e3p27xcPThkSO2R9rr5etL6j8dTTj6%0AsMGloatRvbHyGOFY9rEXTUFNAz9xf2pplmkuaf58PPW48ITfif4Ws5aWVrnWsja0Latt9mT4ybs/%0AO/7c067b3tDB7ig5BaeyTr38JeKXB6c9Tved4Z5pP6t2tq6T2VnchXRt6prvju8W9oT2DJ9zP9fX%0Aa9nb+aver8fPK52vvSBxoewi5WLhxZVLeZcWLqdfnrsSd2Wyb2Pfk6shV+/3+/YPXfO4duO68/Wr%0AA3YDl25Y3Th/0+LmuVvcW923TW93DZoMdv5m8lvnkOlQ1x2zOz13ze/2Dq8ZvjhiM3LlnuO96/fd%0A7t8eXTs6/CDwwcOx8DHhw+iHM4+SH715nP146cn2cfx48VPRp5XP5J41/q71e4fQVHhhwnFi8Ln/%0A8yeTvMlXf2T+sTxV+IL+onJacbplxmjm/Kzz7N2X615OvUp/tTRX9KfYn3WvNV+f/cv2r8H5kPmp%0AN/w3K3+XvpV+e/yd8bu+BZ+FZ+9T3i8tFn+Q/nDiI/fjwKfgT9NLOcvE5arPWp97v3h8GV9JWVn5%0ABy6ikLxSF1/9AAAACXBIWXMAAAxOAAAMTgF/d4wjAAAAHXRFWHRTb2Z0d2FyZQBHUEwgR2hvc3Rz%0AY3JpcHQgOS4wNmqmDDUAAAfnSURBVHic7d3bdrI6AEZRs0ff/5XZF/RPU0CKnxoOznlVFS0drVlC%0AgJZhGG4AEPlvflcppZTSf1X6uPZPB9DZV3tjHF7HrZM61O6ysbIy0E/WZz0J7cKLP938BQHYrkzG%0A2fkYvdcg2w76wZ23ZuVXirjjDwhwAT97tHbfz/PuFVALgJebzotMhvJuI+87EtJuiNz7QaQF4Bk/%0A8yLDMIwD7r2dPHU4nk8qLO4yuhekxdeZPBT/PO1LKQTAu/3aFmkH+vkQX4Mx/FOXbG/WVxifUh+a%0AaEf59ot7Q39dpS1t2H3vHMCH+JrcbjcRFj/Ob7ln3fgtxmf9+dztPVAOgP6mFbn93kkV7xda2bUV%0Av86t2fTZsmT8TQHYaOGsw9FkGiOzMug/Y8sqmRQB6GDtSN9nBuLJfMmraAPAodzdFjmmYMNofrI6%0AAK/yqyKTofZVx92+fATPVmlxNdQF4Bllff5jcZJ8fubHfIHJOSWLD92bD188lWRxlSarvV6XP39A%0AAB7l1DwAciebFwHgUFQEgJyKAJBTEQByKgJATkUAyKkIADkVASCnIgDkVASAnIoAkFMRAHIqAkBO%0ARQDIqQgAORUBIKciAOS+bv73+BL/ApLD8oblOIZh+Kpf7bsqh+JdysF5w3IE41BpjxYAORUBIKci%0AAORUBICcigCQUxEAcioCQE5FAMipCAA5FQEg97X3CnwrpbioA5+gvb6Ov3ku4BAVcd0qPpOicAGd%0AKjK+W4ZhmL9t6j11mcXlvce4NkXhpLpui7S7rUop482aivk7Z1zAlgqfRlE4ka4V2f5+GOMxLr/L%0Au0i6OAhF4eB2mxc5+EaGtytvkv3Z+4PksA4xuw7MKQenoCJwIMrB6exWkSPvzoKelINT23NbxJuH%0Aj+WPn8voegWU8eje2+xM9XqOyOTcEdsrXM94dPveawEvs8ORvosXO5nc420GcAo7XI1RIQAuwzV9%0AAcj1nhfp+e0AeLdO8yL2YgFckj1aAORUBICcigCQUxEAct+z646eAiDwXRHHULU0FWAje7QAyKkI%0AADkVASCnIgDkVASAnIoAkFMRAHIqAkBORQDIqQgAuRNUxPVIAA7r6BWREIAj6/Qfc0dtEur1H8c7%0Ah2GYP1rvqct0W1UAtui3LVJKGf65NYWoN9tH24fGLyQE4IA6bYuMkag3J1set+NtZ9iTdlVH+0uD%0As+u6R6u1/maeVKc/Y80l+XAAL3f02XUAjkxFAMh1nV1fuQnAGXXdFmmP3DXxABxWKcUn3Y06za7X%0Ag7LmZ37U+ydHALdPdL4IsGhlrJ+PM9uXnA9Hxp97+h2jde93MLl/vphfHnBP/YQ6GSjGT5/tOWf3%0APoxOzm6+/T5TbfIQc2bXAX742PooFQE+WrvzauMuE1oqAnwuu6qet9u56wDvMJ/e+HNJnqEiwBVs%0ATIJyvJyKAFewfozWymJvX7OrMy8CXNafkTBt/rzvbRFBBq5k/u8neJOvmxoDl/NoQuplMoyHj7JH%0AC7isIAmL+bFZs8LsOnBi8+uXVIvX0VrZ2qinH66/FBMqApzYxvF9ewYE41H2aAGQUxEAcioCQE5F%0AAMipCAA5FQEgpyIA5FQEgJyKAJBTEQByKgJATkUAyKkIADkVASCnIgDkVASAnIoAkFMRAHIqAkBO%0ARQDIqQgAORUBIKciAORUBICcigCQUxEAcioCQE5FAMipCAA5FQEgpyIA5FQEgJyKAJBTEQByKgJA%0ATkUAyKkIADkVASCnIgDkVASAnIoAkFMRAHIqAkBORQDIqQgAORUBIKciAORUBICcigCQUxEAcioC%0AQE5FAMipCAA5FQEgpyIA5FQEgJyKAJBTEQByX3uvAPCwUsreqwDfVAROZhiGvVcBftijBUBORQDI%0AqQgAORUBIKciAORUBICcigCQUxEAcioCQE5FAMipCAA5FQEgpyIA5FQEgJyKAJBTEQByKgJATkUA%0AyKkIADkVASCnIgDkVASAnIoAkFMRAHIqAkBORQDIqQgAORUBIKciAORUBICcigCQUxEAcioCQE5F%0AAMipCAA5FQEgpyIA5FQEgJyKAJBTEQByKgJATkUAyKkIADkVASCnIgDkVASAnIoAkFMRAHIqAkBO%0ARQDIqQgAORUBIKciAORUBICcigCQUxEAcioCQE5FAMipCAA5FQEgpyIA5L72XgFgk1LK3qvwlGEY%0A9l4F3kJF4DTOOxCfPYGssEcLgJyKAJBTEQByKgJATkUAyKkIADkVASCnInAdrz0tw0kebKEicAWl%0AlHcM+kLCn1QEruAdp7UPw3Des+XpxhVQoIf2Q72hmStREehNUbgSFYE9vaMoi6853jkMQ310fGhl%0ABepTFl/53vKLD3FhKgJH8ZJRuJTS5qHebB+tD92WIjGvy/zR+QLtNxqn+oXkQ6gIn+UsBx1Nthi2%0Aq8u3mx315vho7cTKi0+e/ufati/10HM5OxXhg+z46TgYVY/2WX5l19b6wlybisCBvHbwfXSbYMvy%0A8/kVPpyKwM723ULa/t3n8yhwUxHYRZ+x+NHNhWc2Lxan8eNX40RUBDrZZVR9dP5840ou9qY9PExC%0APodfNpzDlqF55XyOewd9bT9fZH7EV/us9cOUdeXCbIvAdaxveTz6lPUl12/yOVyNEYCcigC/uJAJ%0AD7FHC5hyLgjbqQjwi+0PHmKPFgA5FQEgpyIA5FQEgJzZdTgNh05xQC5LAEDuf/VMEWi0SGTkAAAA%0AAElFTkSuQmCC">
</div>
</div>
<div class="ulist"><ul>
<li>
<p>
Klasa <code>SmartBFC</code>  sadrži pokazivač <code>ptr</code> na objekt tipa <code>BFC</code>
i pokazivač <code>cnt</code> na brojač instanci klase <code>SmartBFC</code> koje pokazuju na isti objekt;
</p>
</li>
<li>
<p>
Konstruktor uzima pokazivač na (dinamički alociran) objekt tipa   <code>BFC</code>
i njime inicijalizira svoj pokazivač. Ujedno na hrpi kreira objekt tipa <code>int</code> koji inicijalizira
jedinicom te inicijalizira <code>cnt</code> s pokazivačem na njega.  Nakon što konstruktor
završi brojač referenci je postavljen na jedinicu.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Napomena</strong>: Klasa <code>SmartBFC</code> nije <em>pametni pokazivač</em> jer ne implementira semantiku pokazivača.
Te ćemo detalje popraviti naknadno.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_brojanje_referenci_konstruktor_kopiranjem">Brojanje referenci -  konstruktor kopiranjem</h2>
<div class="sectionbody">
<div class="paragraph"><p>Kopiranje SmartBFC objekta:</p></div>
<div class="imageblock">
<div class="content">
<img alt="cctor_br_ref.png" src="data:image/png;base64,%0A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%0AH0Ar9v6mvrxoC2coH8AzDoz8VuOniHs5wwXgLstrjyWr1+3cWMCXhn3bD0UN5QO4S2WT6tMlcpcw%0A2wlALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzK%0AB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoH%0AQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdA%0ALMoHQCzKB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsygdALH+e3gGgW+M4Pr0LsEL5gFtM0/T0%0ALsA6s50AxKJ8AMSifADEsl6+cRxrDk1XbgYA71Ge4TKXbD40nVetOFhduRkAvM2/5UsBS/VKf8nb%0AVrkZALxTOdtZOWir2UwIAXihf8qXz14uFaO6r5sNsgfAW92ykj1lryjlpyOCabPlVCoAXOuW8qWG%0AbQwWV2/J4wcAd/jder6NYdx8V/rTgA+A+1jJDkAsj5XPwA6AR/yufA7gAfAG/5RveTWWVZWb1RBC%0AAB5RjvlWg7S8sXKzZHVu04QnAL83rl6Qs7BMVM1my8V52+v5Vr9QvXlRxOFPp3s3fYf4xoPmlOv5%0ALrx62XKbmou/AMCtrGoAIBblAyAW5QMgFuUDIBblAyAW5QMgFuUDIBblAyAW5QMgFuUDIBblAyCW%0A8rqdAJfwTmTbXK/4QcoH3MWL+yd+LXiW2U4AYlE+AGJRPgBiUT5gyziODkrRGWe4AN/l8XPeCq1T%0APmAfFaR1ygccp4K0yHE+4Bpj5vJHfu2j0SJjPgK56SXPK+nSVf8m9/2XGaFGpnxEcdMrXfevoXvb%0Ak/41LonWNE2Xx6/v/y9qKB9wlpbQFuUDjlA72qV8QK1na7d6Hul8Yz4pOt+1cdJp+pTVR/60/epd%0ANEr5gC0vea1Px1PnDhWHV+cP013DWtiWRVzeu9wg/0Lzaasv+QfhDKsagAak3hThmT9Mf+Yfbj9O%0AjaJzmtcNYz4gtI1pz+2NaZcxH7DivmXp5+3NT832ZjJDMeYDvmjuFI9dDVseF6R7xnzADm8YC+79%0A0md2dXnCy+GH4j2UDzjowQruPYelcki3+kTSjaZDu2G2E96roRHGfTOi83KFT4+/usihuOZZ5XG+%0A4mvNZ4p+WilB05QPXu2pV9tj0b1pbw+sUqjfk9VlEgceh4YoH3CKNtAc5QN2a7F2+Yxoi/vPhZQP%0AqNJBLRo6bsqtlA/4qIPaJT09F05SPmCFTtAx6/kAiEX5AIhF+QCIxXE+4C7OpeSdlA+4hXNkeC2z%0AnQDEonwAxKJ8AMSifADEonwAxKJ8AMSifADEonwAxKJ8AMSifADEonwAxKJ8AMSifADEonwAxKJ8%0AAMSifADEonwAxKJ8AMSifADEonwAxKJ8AMSifADEonwAxKJ8AMSifADEonwAxKJ8AMSifADEEqV8%0A4ziO4/j0Xtyo+ycIcJU/T+/A7eYeTNOU/p4+fGpnVhW7tJ2xfOPVJ7h8QABm/ZdvyBqwzMPv9yQP%0AVTKP2PIbP205ZPu/DHn6i/EfwCedz3a+IQB374OxHcAunZdvVrTnl6m4I3v5yPXTc5FDgE86n+1M%0Ac4bFXGIuJWR5kGz1uOCnjq4+TnHXqSfz96FUDeCM/sd8eZlWR2ApctNfQ3bgrUhgali6q5CXKf/L%0ARnfru/iGyVuA1nU+5pvl47BPY6bljXuHVvNXmT/r6+fWN0ztAK4VonzDf2cvz0wYbkx7Hn6cYe3c%0Azo0tD39RAIYIs525q0763wjVyYf9uo2DfAAndV6+ZUtOlqM4/ncVPQP4mc7L14oDY9DHV+UDNKr/%0A8hVtuHaBwfkHyR3bq9XdUESAT/pZHLZ64G1jGcNym+XKvOUGxZq/1bs2Hv/YdTu3/49qniP3uXWF%0ApeWbcId+fq68RvAI5YPm9D/bCQA55QMglh5Wsi8vLfbo7gDwar2N+WQPgG29lQ8AtikfALH0UD4z%0AnADU66F8iQQC8FVX5QOAr5QPgFg6KZ95TgAqdVK+QfwAqNNP+QCghvIBEIvyARCL8gEQi/IBEIvy%0AARBLS+/Pl96Hj9+zaAToRkvlG7z+PsTvHEBPzHYCEIvyARCL8gEQi/IBEIvyARCL8gEQi/IBEIvy%0AARCL8gEQi/LdwkVPAF5L+a4newBv1th1O19ibts0TXnk5muKpluKbfKNXX0U4EHGfMeN4zj9NWSp%0Am+9Nt+cbP7KfAOSU77jKks2bpT/1D+BZZjuvUcx89qfvZweEonxUMVQFumG2E4BYlO8aJgMBWqF8%0AlzEfCNAE5TtuHMd5qFesWEiLHNK9g0EhwGs4w+W4VLjlaG8ZQgBewpjvLGEDaIvyARCL8h3n0B1A%0AixznO8IMJ0C7jPlow7UjbON1iEz5eLu0PuTyh738MYEmKB9vd8fcsjfNgMiUD4BYGjvDxQwV7/T1%0AnYe9NTG8R2Pl89rxiPf8wpHvSfpmmG/M3yIxXV5nuXHxKauP/Gn71buA5jRWPiJLw6bVy6XOH+ZX%0ASV2GbVnE5b3LDfIvNJ9uI37QNMf5aEbqTRGe+cP0Z/7h9uPUWL0cOdA0Yz7Ymvbc2Hg5NCw2+7rB%0AgV0FzjPmo0l7s1GzvZlMCMKYjz7tatjyuGCN5VHGvRsAjzDmo0l7Tzc9c3rq9qQl0Bzlo1V7z2Gp%0AHHKthi3daOgGHTDbSQPms0U+LapbXeRQnGBSeZyv+FrzmaKfVkoAjVI+2nBglUJ9pVaXSex6nK/b%0ASCa8h9lOAGJRvh9xWsQbuAgZMJjt/A3Zew//F4Dy7VZ50eR0b35a4GCo8Sj/+MBgtnOv+QTCdHHI%0A5ZsD5Pfmdw3eDRXgHYz5dtg+b37oekhhkhDohvKdEufNSLt5IgBmOwGIRfkAiEX59nHxYoDWKd9u%0ALl4M0DTl2yFfvVdkL7+o8bAYC6Y1D8aIAI9zbuc+lRdH3n6TUgAeZMwHQCzKB0AsygdALMoHQCzK%0AB0AsygdALMoHQCzKB0AsygdALMoHQCzKB0AsjV230xWfATjJ++wAEMv/AbzOY3WDkrc1AAAAAElF%0ATkSuQmCC">
</div>
</div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">SmartBFC</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartBFC</span> <span class="o">&amp;</span> <span class="n">orig</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">ptr</span><span class="p">),</span> <span class="n">cnt</span><span class="p">(</span><span class="n">orig</span><span class="p">.</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span> <span class="o">++*</span><span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Konstruktor kopije jednostavno kopira pokazivače i povećava brojač referenci za jedan.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">~</span><span class="n">SmartBFC</span><span class="p">(){</span> <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="k">delete</span> <span class="n">cnt</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Destruktor smanjuje brojač za jedan i ako je umanjeni brojač nakon toga jedanak nuli (to znači da nema
više niti jednog <code>SmartBFC</code> objekta koji pokazuje na dani <code>BFC</code> objekt)
dealocira i objekt na koji pokazuje i brojač. Ako nakon smanjivanja brojača on nije jednak nuli destruktor
ne radi ništa. U tom slučaju ima još <code>SmartBFC</code> objekata koji pokazuju na
promatrani objekt i koriste brojač.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">BFC</span> <span class="o">*</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span>         <span class="nf">use_count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
Pomoćna funkcija <code>get()</code> nam omogućava da dohvatimo pokazivač na   pohranjeni objekt.
Funkcija <code>use_count()</code> daje brojač "referenci" na objekt.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_brojanje_referenci_operator_pridruzivanja">Brojanje referenci - operator pridruživanja</h2>
<div class="sectionbody">
<div class="paragraph"><p>Implementacija operatora pridruživanja:</p></div>
<div class="imageblock">
<div class="content">
<img alt="op_br_ref.png" src="data:image/png;base64,%0A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%0AO3pF/h4dbhLssZ5ev3hGe3MG8PsV8fQTOEexIYoZ/vocLOBo1zcNUFWN/Kt+ZQ5D8MjTlXKv/1Pb%0An7w9UQ8nU30gy+sX6a8//8UT6O1FepJPc67rA8VdrrXfvc3leond9O+d/O8usr97XX/jSzOEeidq%0A7hBpxu05MKg+18VwnEqHazP8AJBC9QEgheoDvMTj9CnA3XwAr3JFn9GpPsBLxJ4CzPADQArVB4AU%0Aqg8AKVzXb6neU58A6Nn/AWHtDJ1ace1vAAAAAElFTkSuQmCCiVBORw0KGgoAAAANSUhEUgAAAqcA%0AAAGICAIAAADzld4tAAAACXBIWXMAAAxNAAAMTQHSzq1OAAAAHXRFWHRTb2Z0d2FyZQBHUEwgR2hv%0Ac3RzY3JpcHQgOC42M/QqOFkAAAY9SURBVHic7dUxAQAgDMAwwL/n4QKOJgr6dc/MAgACzu8AAOAR%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK%0A1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArX%0AB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcH%0AgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weACtcHgArXB4AK1weA%0ACtcHgArXB4AK1weACtcHgArXB4CKC3FvBg3Pn5GoAAAAAElFTkSuQmCC">
</div>
</div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">SmartBFC</span><span class="o">&amp;</span> <span class="n">SmartBFC</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartBFC</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
     <span class="o">++*</span><span class="n">rhs</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>
     <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="k">delete</span> <span class="n">cnt</span><span class="p">;</span> <span class="p">}</span>
     <span class="n">ptr</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
     <span class="n">cnt</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">cnt</span><span class="p">;</span>

     <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ovdje, da bismo se zaštitili od "samopridruživanja" prvo povećavamo brojač desne strane,
a onda smanjujemo brojač lijeve strane. Dealokaciju objekta na lijevoj strani vršimo
jedino ako je umanjeni brojač jednak nuli. Nakon toga kopiramo pokazivače. Uočimo da će
kod pridruživanja oblika <code>a=a</code>  doći prvo do povećanja, a zatim smanjenja brojača,
te se tako izbjegava moguća dealokacije objekta.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_primjena">Primjena</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SmartBFC</span> <span class="n">spt1</span><span class="p">(</span><span class="k">new</span> <span class="n">BFC</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cnt (u spt1) ="</span> <span class="o">&lt;&lt;</span> <span class="n">spt1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 1</span>
    <span class="n">SmartBFC</span> <span class="n">spt2</span> <span class="o">=</span> <span class="n">spt1</span><span class="p">;</span> <span class="c1">// CCtor</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"cnt (u spt1) = "</span> <span class="o">&lt;&lt;</span> <span class="n">spt1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 2</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span>   <span class="n">spt1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">SmartBFC</span> <span class="n">spt3</span><span class="p">(</span><span class="k">new</span> <span class="n">BFC</span><span class="p">(</span><span class="mi">33</span><span class="p">));</span>
    <span class="n">spt1</span> <span class="o">=</span> <span class="n">spt3</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Primjena operatora <code>-&gt;</code> kao u ovom slučaju</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">cout</span> <span class="o">&lt;&lt;</span>   <span class="n">spt1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>vrlo je nepraktična, no preopterećenje operatora <code>-&gt;</code>
će nam omogućiti da koristimo prirodnu sintaksu <code>spt1-&gt;get()</code>,
kao da je <code>spt1</code> pokazivač.</p></div>
<div class="paragraph"><p><strong>Napomena</strong>. U standardnoj biblioteci brojanje referenci je implementirano klasom <code>shared_ptr&lt;T&gt;</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_std_shared_ptr_lt_t_gt">std::shared_ptr&lt;T&gt;</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>std::shared_ptr&lt;T&gt;</code> je pametni pokazivač koji implementira brojanje referenci.
Koristimo ga kada želimo imati više pokazivača koji pokazuju na isti element i brinu o njegovom vijeku trajanja.
Definiran je u zaglavlju <code>&lt;memory&gt;</code>.</p></div>
<div class="sect2">
<h3 id="_konstrukcija_2">Konstrukcija</h3>
<div class="ulist"><ul>
<li>
<p>
Konstruktor uzima pokazivač čiji postaje vlasnik.
</p>
</li>
<li>
<p>
Dodijeljeni konstruktor kreira prazan objekt (pokazivač na objekt je <code>nullptr</code>).
</p>
</li>
<li>
<p>
<code>std::shared_ptr&lt;T&gt;</code> ima konstruktore kopije i operator pridruživanja koji implementiraju brojanje referenci.
</p>
</li>
<li>
<p>
<code>std::shared_ptr&lt;T&gt;</code> je moguće konstruirati preuzimanjem resursa <code>std::unique_ptr&lt;T&gt;</code> objekta.
</p>
</li>
<li>
<p>
Funkcija <code>std::make_shared&lt;T&gt;</code> kreira pametni pokazivač na zadanu vrijednost. Interno kreira objekt
  pomoću operatora <code>new</code>. Svoje argumente predaje konstruktoru objekta.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">5</span><span class="p">));</span>
   <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// inicijaliziraj shared pomoću</span>
                                            <span class="c1">// unique</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p3</span><span class="p">{</span><span class="n">p1</span><span class="p">};</span>  <span class="c1">// CCtor</span>

   <span class="n">p2</span> <span class="o">=</span> <span class="n">p3</span><span class="p">;</span>  <span class="c1">// OP</span>

   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// daje 3</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">unique</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// false</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"adresa = "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

 <span class="c1">// Ako imao samo vrijednost koju želimo pohraniti u</span>
   <span class="c1">// shared_ptr koristimo make_shared.</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">11</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p4</span> <span class="o">&lt;&lt;</span>  <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"adresa = "</span> <span class="o">&lt;&lt;</span> <span class="n">p4</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Neke od metoda klase <code>std::shared_ptr&lt;T&gt;</code> su iste kao i kod klase  <code>std::unique_ptr&lt;T&gt;</code>:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Poziv  </th>
<th align="left" valign="top"> Značenje</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>a.get()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća pokazivač koji <code>a</code> drži.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.unique()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća <code>true</code> ako <code>use_count()</code> vraća 1 odnosno <code>false</code> u suprotnom.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.use_count()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća broj referenci, odnosno  broj <code>std::shared_ptr&lt;T&gt;</code> objekata koji drže isti pokazivač.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.reset()</code></p></td>
<td align="left" valign="top"><p class="table">Odriče se vlasništva nad objektom.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.reset(ptr)</code></p></td>
<td align="left" valign="top"><p class="table">Objekt kojeg je do sada držao zamijenjuje s <code>ptr</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="ulist"><ul>
<li>
<p>
<code>std::shared_ptr&lt;T&gt;</code> drži pokazivač na dinamički alociran objekt. Pogrešno mu je dati adresu
objekta koji nije dinamički alociran! Ako imamo samo objekt, a želimo ga kontrolirati pomoću  <code>std::shared_ptr&lt;T&gt;</code>
objekta, treba koristiti funkciju <code>std::make_shared&lt;T&gt;</code> (iz zaglavlja <code>&lt;memory&gt;</code>).
</p>
</li>
<li>
<p>
Destruktor klase   <code>std::shared_ptr&lt;T&gt;</code> poziva operatir <code>delete</code> na pokazivaču koji drži.
</p>
</li>
<li>
<p>
Metoda <code>release()</code> ne postoji.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_std_shared_ptr_lt_t_gt_i_polja">std::shared_ptr&lt;T&gt; i polja</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ako pokazivač na polje želimo čuvati u  <code>std::shared_ptr&lt;T&gt;</code> objekt, tada pri konstrukciji trebamo zadati
<em>deleter</em>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="n">spv</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="p">[](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="p">});</span>
   <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
       <span class="n">spv</span><span class="p">.</span><span class="n">get</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<em>Deleter</em> je funkcija koja uzima pokazivač na tip i ne vraća ništa.
</p>
</li>
<li>
<p>
Za razliku od  <code>std::unique_ptr&lt;T&gt;</code> ne možemo pisati  <code>std::shared_ptr&lt;T[]&gt;</code> već moramo zadati <em>deleter</em>
eksplicitno. Sučelje klase se ne mijenja  i nemamo operatora indeksiranja.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_std_shared_ptr_lt_t_gt_i_cirkularna_zavisnost">std::shared_ptr&lt;T&gt; i cirkularna zavisnost</h2>
<div class="sectionbody">
<div class="paragraph"><p>Brojanje referenci uvodi mogućnost cirkularne zavisnosti.</p></div>
<div class="ulist"><ul>
<li>
<p>
Objekt <code>A</code> drži pokazivač na objekt <code>B</code> dok objekt <code>B</code>  drži pokazivač na objekt  <code>A</code>.
  U tom slučaju nikad neće doći do dealokacije memorije.
</p>
</li>
</ul></div>
<div class="paragraph"><p><strong>Primjer</strong>. Klasa koja drži pametne pokazivače:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;&gt;</span> <span class="n">staff</span><span class="p">;</span>

        <span class="n">Employee</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">name_</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">head_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name_</span><span class="p">),</span>
                                                              <span class="n">head</span><span class="p">(</span><span class="n">head_</span><span class="p">)</span>
        <span class="p">{}</span>
        <span class="o">~</span><span class="n">Employee</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" izbrisan</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// nema potrebe za ručnom dealokacijom</span>
     <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Funkcija za kreiranje instance klase:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">init</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">name</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">boss</span><span class="p">(</span><span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">" boss"</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">dept_boss</span><span class="p">(</span><span class="k">new</span> <span class="n">Employee</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">boss</span><span class="p">));</span>
        <span class="n">boss</span><span class="o">-&gt;</span><span class="n">staff</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dept_boss</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">dept_boss</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>U glavnom programu …</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// ...</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">dboss</span> <span class="o">=</span> <span class="n">init</span><span class="p">(</span><span class="s">"Damir"</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">dboss</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" use_count = "</span> <span class="o">&lt;&lt;</span> <span class="n">dboss</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

   <span class="c1">// Do dealokacije neće nikad doći!</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Da ne dolazi do dealokacije možemo provjeriti pomoću valgrind-a</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">valgrind</span> <span class="o">--</span><span class="n">tool</span><span class="o">=</span><span class="n">memcheck</span> <span class="o">--</span><span class="n">leak</span><span class="o">-</span><span class="n">check</span><span class="o">=</span><span class="n">yes</span> <span class="p">.</span><span class="o">/</span><span class="n">a</span><span class="p">.</span><span class="n">out</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_std_weak_ptr_lt_t_gt">std::weak_ptr&lt;T&gt;</h2>
<div class="sectionbody">
<div class="paragraph"><p>Klasa <code>weak_ptr&lt;T&gt;</code> omogućava dijeljenje dinamički alociranog objekta <strong>bez vlasništva nad objektom</strong>.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>weak_ptr&lt;T&gt;</code> najčešće kreiramo iz <code>shared_ptr&lt;T&gt;</code> objekta. Oni tada pokazuju na isti objekt.
   Dodijeljeni konstruktor kreira prazan pokazivač (onaj koji drži <code>nullptr</code>).
</p>
</li>
<li>
<p>
Metoda <code>use_count()</code> nikad ne broji  <code>weak_ptr&lt;T&gt;</code> objekte koji drže pokazivač na objekt; ona broji samo
   <code>shared_ptr&lt;T&gt;</code> objekte.
</p>
</li>
<li>
<p>
<code>weak_ptr&lt;T&gt;</code> nikad ne dealocira svoj objekt.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="n">sp1</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>  <span class="n">sp2</span><span class="p">(</span><span class="n">sp1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">wp1</span><span class="p">(</span><span class="n">sp2</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">wp1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 2</span>

<span class="k">if</span><span class="p">(</span><span class="n">wp1</span><span class="p">.</span><span class="n">expired</span><span class="p">())</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"wp1 drži nullptr.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"wp1 pokazuje na objekt.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Klasa  <code>weak_ptr&lt;T&gt;</code> ima minimalno sučelje i ne može direktno dohvatiti objekt na koji pokazuje
(niti za čitanje niti za pisanje).
Da bi mogla dohvatiti objekt prvo mora kreirati <code>std::shared_ptr&lt;T&gt;</code> pomoću <code>lock()</code> metode.</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Poziv  </th>
<th align="left" valign="top"> Značenje</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>a.use_count()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća broj referenci, odnosno  broj <code>std::shared_ptr&lt;T&gt;</code> objekata koji drže isti pokazivač.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.expired()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća <code>true</code> ako je prazan. Isto što i    <code>a.use_count() == 0</code>, ali efikasnije.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.lock()</code></p></td>
<td align="left" valign="top"><p class="table">Vraća <code>std::shared_ptr&lt;T&gt;</code> koji sadrži isti pokazivač.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Na primjer (nastavak),</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">a</span> <span class="o">=</span><span class="n">wp1</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
<span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">17</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">wp1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 3</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">wp1</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 17</span>
</pre></div></div></div>
<div class="paragraph"><p><code>weak_ptr&lt;T&gt;</code> je namijenjen i za korištenje u situacijama kada nadživi objekt na koji pokazuje.
Stoga prije uptrebe metode <code>lock()</code> treba uvijek ispitati objekt sa <code>expired()</code> metodom.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_std_weakptr_lt_t_gt_i_rjesenje_cirkularne_zavisnosti">std::weakptr&lt;T&gt; i rješenje cirkularne zavisnosti</h2>
<div class="sectionbody">
<div class="paragraph"><p>Korištenjem klase <code>std::weak_ptr&lt;Employee&gt;</code> prekida se cirkularna zavisnost i
objekti se normalno dealociraju.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// std::weak_ptr&lt;Employee&gt; iprekida cirkularnu zavisnost.</span>
<span class="k">class</span> <span class="nc">Employee</span><span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">head</span><span class="p">;</span>
        <span class="c1">//std::vector&lt;std::shared_ptr&lt;Employee&gt;&gt; staff;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;&gt;</span> <span class="n">staff</span><span class="p">;</span>

        <span class="n">Employee</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">name_</span><span class="p">,</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">head_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name_</span><span class="p">),</span>
                                                              <span class="n">head</span><span class="p">(</span><span class="n">head_</span><span class="p">)</span>
        <span class="p">{}</span>
        <span class="o">~</span><span class="n">Employee</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" izbrisan</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
         <span class="c1">// nema potrebe za ručnom dealokacijom</span>
<span class="p">};</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_alokatori">Alokatori</h2>
<div class="sectionbody">
<div class="paragraph"><p>Svi spremnici imaju jedan dodatni parametar predloška, tzv. <strong>alokator</strong>. Na primjer,
<code>std::vector</code> ima deklaraciju:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span>
    <span class="k">class</span> <span class="nc">T</span><span class="p">,</span>
    <span class="k">class</span> <span class="nc">Allocator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="o">&gt;</span> <span class="k">class</span> <span class="nc">vector</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Alokator brine o alokaciji i dealokaciji memorije. Operatori <code>new</code> i <code>delete</code> se ne koriste
neposredno zbog ovog "nedostatka":</p></div>
<div class="ulist"><ul>
<li>
<p>
Operator <code>new</code> kombinira alokaciju memorije i konstrukciju objekta u njoj.
</p>
</li>
<li>
<p>
Operator <code>delete</code> kombinira destrukciju objekta i dealokaciju memorije,
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ta svojstva ovih operatora bi dovela do gubitka efikasnosti kod klasa kao što je <code>std::vector&lt;T&gt;</code>
koje alociraju više memorije no što
drže elemenata. Bez alokatora sva bi memorija morala biti konstruirana (s dodijeljenim konstruktorom).</p></div>
<div class="paragraph"><p>Alokator iz zaglavlja <code>&lt;memory&gt;</code> nam omogućava da razdvojimo fazu alokacije
memorije od konstrukcije objekta u memoriji  te, isto tako fazu destrukcije objekta i dealokaciju
memorije. Dodijeljeni alokator iz standardne biblioteke je <code>std::allocator&lt;T&gt;</code>. Korisnici mogu
pisati vlastite alokatore ako za tim imaju potrebe.</p></div>
<div class="paragraph"><p>Ovdje su prikazane metode alokatora:</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Poziv  </th>
<th align="left" valign="top"> Značenje</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>allocator&lt;T&gt; a</code></p></td>
<td align="left" valign="top"><p class="table">Definira alokator <code>a</code> koji alocira memoriju za tip <code>T.</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.allocate(n)</code></p></td>
<td align="left" valign="top"><p class="table">Alocira neinicijaliziranu memoriju za <code>n</code> objekata tip <code>T</code>. Vraća pokazivač na alociranu memoriju.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.deallocate(p,n)</code></p></td>
<td align="left" valign="top"><p class="table">Dealocira memoriju koja sadrži prostor za <code>n</code> objekata tip <code>T</code> i na koju pokazuje pokazivač <code>p</code>.
Pokazivač <code>p</code> mora biti dobiven od <code>allocate</code> i <code>n</code> mora biti korišten u pozivu metode <code>allocate</code>. Objekti koji su eventualno
konstruirani u toj memoriji moraju biti uništeni metodom <code>destroy()</code> prije poziva <code>deallocate</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.construct(p, args)</code></p></td>
<td align="left" valign="top"><p class="table"><code>p</code> mora biti pokazivač tipa <code>T</code> na neinicijaliziranu memoriju; <code>args</code> su argumenti za konstruktor
tipa <code>T</code> koji se koriste da bi se na mjestu na koje pokazuje <code>p</code> konstruirao objekt tipa <code>T</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>a.destroy(p)</code></p></td>
<td align="left" valign="top"><p class="table"><code>p</code> mora biti pokazivač tipa <code>T</code>. Pozovi destruktor na objektu na koji pokazuje <code>p</code>.
Objekt mora prije toga biti konstruiran na tom mjestu.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Korisne mogu biti još dvije metode iz <code>memory</code> zaglavlja;</p></div>
<div class="tableblock">
<table rules="all" width="100%" frame="border" cellspacing="0" cellpadding="4">
<colgroup><col width="30%">
<col width="70%">
</colgroup><thead>
<tr>
<th align="left" valign="top"> Poziv  </th>
<th align="left" valign="top"> Značenje</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>uninitialized_copy(b,e,b2)</code></p></td>
<td align="left" valign="top"><p class="table">Kopira elemente iz raspona danog s iteratorima <code>b</code> i <code>e</code> u neinicijaliziranu memoriju na koju pokazuje <code>b2</code>, koji mora pokazivati na dovoljnu količinu memorije.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>uninitialized_fill(b,e,t)</code></p></td>
<td align="left" valign="top"><p class="table">Konstruira objekte u neinicijaliziranoj memoriji omeđenoj s iteratorima <code>b</code> i <code>e</code> kopirajući element <code>t</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Postoje i <strong>copy_n</strong> i <strong>fill_n</strong> verzije tih funkcija koje uzimaju polazni iterator i broj elemenata.</p></div>
</div>
</div>
</div>

<div id="footer">
<div id="footer-text">
Version 1.0<br>
Zadnja izmjena
 2019-05-14 10:15:46 CEST
</div>
</div>


</body></html>